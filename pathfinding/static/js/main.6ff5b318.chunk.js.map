{"version":3,"sources":["components/Node.jsx","context/pathfindingContext.jsx","components/NavBar.jsx","components/Legend.jsx","algorithms/dijsktra.js","algorithms/bi-directional-bfs.js","algorithms/best-first-search.js","algorithms/astar.js","maze-algorithms/recursiveDivision.js","maze-algorithms/recursiveVertical.js","maze-algorithms/recursiveHorizontal.js","components/PathfindingVisualizer.jsx","maze-algorithms/basicRandom.js","algorithms/bfs.js","algorithms/dfs.js","App.jsx","index.js"],"names":["Node","props","row","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseLeave","onMouseUp","distance","totalDistance","showNumbers","extraClassName","id","className","Infinity","pathfindingContext","createContext","pathfindingReducer","state","action","type","currentAlgorithm","payload","currentMaze","startNode","endNode","speed","initialState","visited","shortestPath","PathfindingContextProvider","useReducer","dispatch","Provider","value","children","pathfindingAlgorithms","Djisktra","mazeAlgorithms","speeds","Fast","Average","Slow","NavBar","console","log","useState","algorithm","setAlgorithm","setSpeed","useContext","Navbar","bg","variant","Brand","width","height","alt","Toggle","aria-controls","Collapse","Nav","fill","NavDropdown","title","Object","keys","map","Item","key","onClick","e","maze","mazeClick","Button","visualizeClick","Link","resetClick","clearClick","Legend","src","dijkstra","grid","finishNode","visitedNodesInOrder","unvisitedNodes","getAllNodes","length","sortNodesByDistance","closestNode","shift","isVisited","push","updateUnvisitedNeighbors","sort","nodeA","nodeB","node","unvisitedNeighbors","getUnvisitedNeighbors","neighbor","previousNode","neighbors","filter","nodes","bi_bfs","unvisitedNodesStart","unvisitedNodesFinish","exploredNodesStart","exploredNodesFinish","biDistance","startingCurrentNode","finishCurrentNode","forEach","biPreviousNode","_bi_bfs","middleNode","updateNode","distanceFromNeighbor","distanceToCompare","weight","targetNode","yChange","Math","abs","manhattanDistance","bestfs","heuristicDistance","astar","randomNumber","array","floor","random","randomColNRow","rowStart","rowEnd","colStart","colEnd","orientation","possibleCols","possibleRows","number","randomColIndex","randomRowIndex","addInnerWalls","colRandom","currentRow","addVerticalWall","currentCol","rowRandom","addHorizontalWall","recursiveDivision","wallsToAnimate","addOuterWalls","nodesToUpdate","createNode","resetNode","dragEnterNode","document","getElementById","newNode","setNode","PathfindingVisualizer","setGrid","mouseIsPressed","setMouseIsPressed","START_NODE","END_NODE","useEffect","getInitialGrid","nodesInShortestPathOrder","fromStart","fromFinish","toStart","toEnd","reverse","concat","getBiDirectionalShortestPath","getNodesInShortestPathOrder","currentNode","unshift","i","setTimeout","animateShortestPath","animatePath","wallNodesInOrder","currentY","counter","currentXOne","currentXTwo","currentNodeOne","currentNodeTwo","basicRandom","recursiveVertical","recursiveHorizontal","animateMaze","newGrid","slice","rowIdx","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseLeave","handleMouseUp","renderGrid","dragLeaveNode","updatedGridWithWalls","exploredNodes","bfs","pop","dfs","App","ReactDOM","render"],"mappings":"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","file":"static/js/main.6ff5b318.chunk.js","sourcesContent":["import React from 'react';\nimport './Node.scss';\n\nfunction Node(props) {\n  // console.log('RENDERING NODE');\n  const {\n    row,\n    col,\n    isFinish,\n    isStart,\n    isWall,\n    onMouseDown,\n    onMouseEnter,\n    onMouseLeave,\n    onMouseUp,\n    distance,\n    totalDistance,\n    showNumbers,\n  } = props;\n  const extraClassName = isFinish ? 'node-finish' : isStart ? 'node-start' : isWall ? 'node-wall' : '';\n\n  return (\n    <div\n      id={`node-${row}-${col}`}\n      className={`node ${extraClassName}`}\n      onMouseDown={() => onMouseDown(row, col)}\n      onMouseEnter={() => onMouseEnter(row, col)}\n      onMouseLeave={() => onMouseLeave(row, col)}\n      onMouseUp={() => onMouseUp(row, col)}>\n      {showNumbers && (\n        <span className='node-distance'>{distance !== Infinity && (totalDistance !== Infinity ? totalDistance : distance)}</span>\n      )}\n    </div>\n  );\n}\n\nexport default Node;\n// export default React.memo(Node);\n","import React, { createContext, useReducer } from 'react';\nexport const pathfindingContext = createContext();\n\nconst speed = {\n  Fast: { visited: 10, shortestPath: 50 },\n  Average: { visited: 40, shortestPath: 75 },\n  Slow: { visited: 70, shortestPath: 100 },\n};\n\nconst pathfindingReducer = (state, action) => {\n  switch (action.type) {\n    case 'SET_ALGORITHM':\n      return { ...state, currentAlgorithm: action.payload };\n    case 'SET_MAZE':\n      return { ...state, currentMaze: action.payload };\n    case 'SET_START_NODE':\n      return { ...state, startNode: action.payload };\n    case 'SET_END_NODE':\n      return { ...state, endNode: action.payload };\n    case 'SET_SPEED':\n      return { ...state, speed: action.payload };\n    case 'TOGGLE_NUMBERS':\n      return { ...state, showNumbers: !state.showNumbers };\n    default:\n      return state;\n  }\n};\nconst initialState = {\n  startNode: { row: 15, col: 15 },\n  endNode: { row: 15, col: 55 },\n  currentAlgorithm: 'DEPTH_FIRST_SEARCH',\n  currentMaze: 'RECURSIVE_DIVISION',\n  speed: speed.Fast,\n  showNumbers: false,\n};\n\nexport default function PathfindingContextProvider(props) {\n  const [state, dispatch] = useReducer(pathfindingReducer, initialState);\n\n  return <pathfindingContext.Provider value={{ state, dispatch }}>{props.children}</pathfindingContext.Provider>;\n}\n","import React, { useContext, useState } from 'react';\nimport { Navbar, Nav, NavDropdown, Button } from 'react-bootstrap';\nimport { pathfindingContext } from '../context/pathfindingContext';\n\nimport './NavBar.scss';\n\nconst pathfindingAlgorithms = {\n  'Depth First Search': 'DEPTH_FIRST_SEARCH',\n  'Breadth First Search': 'BREADTH_FIRST_SEARCH',\n  'Greedy Best Search': 'BEST_FIRST_SEARCH',\n  Djisktra: 'DJISKTRA',\n  'A*': 'A_STAR',\n  // 'Bi Directional BFS': 'BI_DIRECTIONAL_BFS',\n};\n\nconst mazeAlgorithms = {\n  'Recursive Division': 'RECURSIVE_DIVISION',\n  'Basic Random': 'BASIC_RANDOM',\n  'Recursive Vertical Bias': 'RECURSIVE_VERTICAL',\n  'Recursive Horizontal Bias': 'RECURSIVE_HORIZONTAL',\n};\n\nconst speeds = {\n  Fast: { visited: 10, shortestPath: 50 },\n  Average: { visited: 40, shortestPath: 75 },\n  Slow: { visited: 70, shortestPath: 100 },\n};\n\nexport default function NavBar(props) {\n  console.log('RENDERING NAVBAR');\n  const [algorithm, setAlgorithm] = useState('Depth First Search');\n  const [speed, setSpeed] = useState('');\n  const { state, dispatch } = useContext(pathfindingContext);\n\n  function handleAlgorithm(value) {\n    setAlgorithm(value);\n    dispatch({ type: 'SET_ALGORITHM', payload: pathfindingAlgorithms[value] });\n  }\n\n  function handleMaze(value) {\n    props.mazeClick(value);\n    // dispatch({ type: 'SET_MAZE', payload: value });\n  }\n\n  function handleSpeed(value) {\n    setSpeed(value);\n    dispatch({ type: 'SET_SPEED', payload: speeds[value] });\n  }\n\n  function handleToggle(value) {\n    dispatch({ type: 'TOGGLE_NUMBERS' });\n  }\n\n  return (\n    <Navbar bg='dark' variant='dark'>\n      <Navbar.Brand>\n        <img width='35' height='35' alt='Pathfinding Visualizer Logo'></img>\n        <span className='navbar-brand-text'>PathFinding Visualizer</span>\n      </Navbar.Brand>\n      <Navbar.Toggle aria-controls='navbar-nav' />\n      <Navbar.Collapse id='navbar-nav'>\n        <Nav fill className='mr-auto'>\n          <NavDropdown title='Algorithms' id='algorithms-nav-dropdown'>\n            {Object.keys(pathfindingAlgorithms).map(algorithm => (\n              <NavDropdown.Item key={algorithm} onClick={e => handleAlgorithm(algorithm)}>\n                {algorithm}\n              </NavDropdown.Item>\n            ))}\n          </NavDropdown>\n          <NavDropdown title='Maze & Patterns' id='maze-nav-dropdown'>\n            {Object.keys(mazeAlgorithms).map(maze => (\n              <NavDropdown.Item key={maze} onClick={() => handleMaze(mazeAlgorithms[maze])}>\n                {maze}\n              </NavDropdown.Item>\n            ))}\n          </NavDropdown>\n          <Nav.Item>\n            <Button variant='primary' onClick={props.visualizeClick}>\n              Visualize {algorithm}\n            </Button>\n          </Nav.Item>\n          <Nav.Link onClick={props.resetClick}>Clear Board</Nav.Link>\n          <Nav.Link onClick={props.clearClick}>Clear Path</Nav.Link>\n        </Nav>\n        <NavDropdown title={`Speed${speed ? ': ' + speed : ''}`} id='speed-nav-dropdown'>\n          {Object.keys(speeds).map(speed => (\n            <NavDropdown.Item key={speed} onClick={() => handleSpeed(speed)}>\n              {speed}\n            </NavDropdown.Item>\n          ))}\n        </NavDropdown>\n        <Nav.Link onClick={handleToggle}>Show Numbers</Nav.Link>\n      </Navbar.Collapse>\n    </Navbar>\n  );\n}\n","import React from 'react';\nimport './Legend.scss';\nexport default function Legend(props) {\n  return (\n    <div id='pathfinding-legend'>\n      <ul className='legend-container'>\n        <li>\n          <img src={'./start.png'} alt='start node'></img>\n          <span className='legend-text'>Start Node</span>\n        </li>\n        <li>\n          <img src={'./end.png'} alt='target node'></img>\n          <span className='legend-text'>Target Node</span>\n        </li>\n        <li>\n          <div className='legend-unvisited'></div>\n          <span className='legend-text'>Unvisited Node</span>\n        </li>\n        <li>\n          <div className='legend-visited'></div>\n          <span className='legend-text'>Visited Node</span>\n        </li>\n        <li>\n          <div className='legend-shortest-path'></div>\n          <span className='legend-text'>Shortest Path</span>\n        </li>\n        <li>\n          <div className='legend-wall'></div>\n          <span className='legend-text'>Wall</span>\n        </li>\n      </ul>\n      <div className='legend-msg'>Visualize an algorithm!</div>\n    </div>\n  );\n}\n","export function dijkstra(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n\n  // use !! to force boolean conversion\n  while (!!unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift(); // Get the first Node\n\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n\n    // If the closest node is a distance of ifinity,\n    // we must be trapped and should therefore stop.\n\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n}\n\nconst sortNodesByDistance = function(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n};\n\nconst updateUnvisitedNeighbors = function(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n};\n\nconst getUnvisitedNeighbors = function(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n};\n\n// split into utility function\nconst getAllNodes = function(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n};\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above\nexport function getNodesInShortestPathOrder(finishNode) {\n  const getNodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    getNodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n\n  return getNodesInShortestPathOrder;\n}\n","const getUnvisitedNeighbors = function(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  // console.log(neighbors.filter(neighbor => !neighbor.isVisited));\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n};\n\nexport function getBiDirectionalShortestPath(middleNode) {\n  const fromStart = [];\n  const fromFinish = [];\n\n  let toStart = middleNode;\n  let toEnd = middleNode.biPreviousNode;\n  while (toStart !== null) {\n    fromStart.push(toStart);\n    toStart = toStart.previousNode;\n  }\n  while (toEnd !== null) {\n    fromFinish.push(toEnd);\n    toEnd = toEnd.biPreviousNode;\n  }\n  const shortestPath = fromStart.reverse().concat(fromFinish);\n  return shortestPath;\n}\n\nexport function bi_bfs(grid, startNode, finishNode) {\n  const [middleNode, visitedNodesInOrder] = _bi_bfs(grid, startNode, finishNode);\n  return [visitedNodesInOrder, middleNode];\n}\n\nfunction _bi_bfs(grid, startNode, finishNode) {\n  const unvisitedNodesStart = [startNode];\n  const unvisitedNodesFinish = [finishNode];\n  const visitedNodesInOrder = [];\n  const exploredNodesStart = {};\n  const exploredNodesFinish = {};\n  startNode.distance = 0;\n  finishNode.biDistance = 0;\n\n  while (unvisitedNodesStart.length && unvisitedNodesFinish.length) {\n    // for (let i = 0; i < 5; i++) {\n    let startingCurrentNode = unvisitedNodesStart.shift();\n    // FINISH NODE\n    let finishCurrentNode = unvisitedNodesFinish.shift();\n    // If we encounter a wall, we skip it.\n\n    if (startingCurrentNode.isWall) continue;\n    if (finishCurrentNode.isWall) continue;\n\n    // If the current node is a distance of ifinity,\n    // we must be trapped and should therefore stop.\n\n    if (startingCurrentNode.distance === Infinity || finishCurrentNode.biDistance === Infinity) return visitedNodesInOrder;\n\n    // visited node\n    if (!startingCurrentNode.isStart && !finishCurrentNode.isFinish) {\n      if (exploredNodesFinish[startingCurrentNode.id]) {\n        // console.log('EXPLOREDNODE', exploredNodes);\n        console.log('VISITED NODES', visitedNodesInOrder);\n        console.log('startingNode', startingCurrentNode);\n        return [startingCurrentNode, visitedNodesInOrder];\n      } else if (exploredNodesStart[finishCurrentNode.id]) {\n        console.log('VISITED NODES', visitedNodesInOrder);\n        console.log('EndingNode', finishCurrentNode);\n        return [finishCurrentNode, visitedNodesInOrder];\n      } else if (startingCurrentNode.id === finishCurrentNode.id) {\n        console.log('THEY MATCH');\n        return visitedNodesInOrder;\n      }\n    }\n\n    startingCurrentNode.isVisited = true;\n    finishCurrentNode.isVisited = true;\n\n    exploredNodesStart[startingCurrentNode.id] = true;\n    exploredNodesFinish[finishCurrentNode.id] = true;\n    visitedNodesInOrder.push(startingCurrentNode);\n    visitedNodesInOrder.push(finishCurrentNode);\n\n    const currentNeighborsStart = getUnvisitedNeighbors(startingCurrentNode, grid);\n    currentNeighborsStart.forEach(neighbor => {\n      if (!exploredNodesStart[neighbor.id]) {\n        neighbor.distance = startingCurrentNode.distance + 1;\n        neighbor.previousNode = startingCurrentNode;\n        unvisitedNodesStart.push(neighbor);\n      }\n    });\n\n    const currentNeighborsFinish = getUnvisitedNeighbors(finishCurrentNode, grid);\n    currentNeighborsFinish.forEach(neighbor => {\n      if (!exploredNodesFinish[neighbor.id]) {\n        neighbor.biDistance = finishCurrentNode.biDistance + 1;\n        neighbor.biPreviousNode = finishCurrentNode;\n        unvisitedNodesFinish.push(neighbor);\n      }\n    });\n  }\n  return -1;\n}\n","const sortNodesByDistance = function(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n};\n\nconst updateUnvisitedNeighbors = function(node, grid, startNode, finishNode) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    updateNode(node, neighbor, startNode, finishNode);\n  }\n};\n\nconst updateNode = function(node, neighbor, startNode, finishNode) {\n  const distance = distanceFromNeighbor(node, neighbor);\n  const distanceToCompare = neighbor.weight + distance + manhattanDistance(neighbor, finishNode);\n\n  if (distanceToCompare < neighbor.distance) {\n    neighbor.distance = distanceToCompare;\n    neighbor.previousNode = node;\n  }\n};\n\nfunction distanceFromNeighbor(node, neighbor) {\n  if (node.row === neighbor.row - 1 && node.col === neighbor.col) {\n    // console.log('LEFT');\n    return 1;\n  }\n  if (node.row === neighbor.row + 1 && node.col === neighbor.col) {\n    // console.log('RIGHT');\n    return 1;\n  }\n  if (node.col === neighbor.col + 1 && node.row === neighbor.row) {\n    // console.log('UP');\n    return 1;\n  }\n  if (node.col === neighbor.col - 1 && node.row === neighbor.row) {\n    // console.log('DOWN');\n    return 1;\n  }\n}\n\nfunction manhattanDistance(node, targetNode) {\n  let yChange = Math.abs(node.row - targetNode.row);\n  let xChange = Math.abs(node.col - targetNode.col);\n  return xChange + yChange;\n}\n\nconst getUnvisitedNeighbors = function(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n};\n\n// split into utility function\nconst getAllNodes = function(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n};\n\n// Backtracks from the finishNode to find the shortest path.\nexport function getNodesInShortestPathOrder(finishNode) {\n  const getNodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    getNodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n\n  return getNodesInShortestPathOrder;\n}\n\nexport function bestfs(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n\n  // use !! to force boolean conversion\n  while (!!unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift(); // Get the first Node\n\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n\n    // If the closest node is a distance of ifinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n\n    visitedNodesInOrder.push(closestNode);\n\n    closestNode.isVisited = true;\n\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid, startNode, finishNode);\n  }\n}\n","const sortNodesByDistance = function(unvisitedNodes) {\n  // sort by total distance first, if they are the same, sortby heuristicdistance\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.totalDistance - nodeB.totalDistance || nodeA.heuristicDistance - nodeB.heuristicDistance);\n};\n\nconst updateNode = function(node, neighbor, startNode, finishNode) {\n  const distance = distanceFromNeighbor(node, neighbor);\n  // set heuristic distance if there isnt one\n  if (!neighbor.heuristicDistance) neighbor.heuristicDistance = manhattanDistance(neighbor, finishNode);\n  const distanceToCompare = neighbor.weight + distance + node.distance;\n\n  if (distanceToCompare < neighbor.distance) {\n    neighbor.distance = distanceToCompare;\n    neighbor.totalDistance = neighbor.distance + neighbor.heuristicDistance;\n    neighbor.previousNode = node;\n  }\n};\n\nconst updateUnvisitedNeighbors = function(node, grid, startNode, finishNode) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    updateNode(node, neighbor, startNode, finishNode);\n  }\n};\n\nfunction distanceFromNeighbor(node, neighbor) {\n  if (node.row === neighbor.row - 1 && node.col === neighbor.col) {\n    // console.log('LEFT');\n    return 1;\n  }\n  if (node.row === neighbor.row + 1 && node.col === neighbor.col) {\n    // console.log('RIGHT');\n    return 1;\n  }\n  if (node.col === neighbor.col + 1 && node.row === neighbor.row) {\n    // console.log('UP');\n    return 1;\n  }\n  if (node.col === neighbor.col - 1 && node.row === neighbor.row) {\n    // console.log('DOWN');\n    return 1;\n  }\n}\n\nfunction manhattanDistance(node, targetNode) {\n  let yChange = Math.abs(node.row - targetNode.row);\n  let xChange = Math.abs(node.col - targetNode.col);\n  return xChange + yChange;\n}\n\nconst getUnvisitedNeighbors = function(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n};\n\n// split into utility function\nconst getAllNodes = function(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n};\n\n// Backtracks from the finishNode to find the shortest path.\nexport function getNodesInShortestPathOrder(finishNode) {\n  const getNodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    getNodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n\n  return getNodesInShortestPathOrder;\n}\n\nexport function astar(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n\n  startNode.distance = 0;\n  startNode.totalDistance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n\n  // use !! to force boolean conversion\n  while (!!unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    // console.log(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift(); // Get the first Node\n\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n\n    // If the closest node is a distance of ifinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n\n    visitedNodesInOrder.push(closestNode);\n\n    closestNode.isVisited = true;\n\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid, startNode, finishNode);\n  }\n}\n","function randomNumber(array) {\n  return Math.floor(Math.random() * array.length);\n}\n\nfunction randomColNRow(rowStart, rowEnd, colStart, colEnd, orientation) {\n  const possibleCols = [];\n  const possibleRows = [];\n  if (orientation === 'horizontal') {\n    // walls on even cells only\n    for (let number = rowStart; number <= rowEnd; number += 2) {\n      possibleRows.push(number);\n    }\n    // openings in odd cells only\n    for (let number = colStart - 1; number <= colEnd + 1; number += 2) {\n      possibleCols.push(number);\n    }\n  } else {\n    for (let number = colStart; number <= colEnd; number += 2) {\n      possibleCols.push(number);\n    }\n    for (let number = rowStart - 1; number <= rowEnd + 1; number += 2) {\n      possibleRows.push(number);\n    }\n  }\n  const randomColIndex = randomNumber(possibleCols);\n  const randomRowIndex = randomNumber(possibleRows);\n  const colRandom = possibleCols[randomColIndex];\n  const rowRandom = possibleRows[randomRowIndex];\n  return [colRandom, rowRandom];\n}\n\nconst getAllNodes = function(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n};\n\nfunction addOuterWalls(grid, array) {\n  const width = grid[0].length - 1;\n  const height = grid.length - 1;\n  for (let row = 0; row < grid.length; row++) {\n    if (row === 0 || row === height) {\n      for (let col = 0; col <= width; col++) {\n        const node = grid[row][col];\n        node.isWall = true;\n        array.push(node);\n      }\n    } else {\n      grid[row][0].isWall = true;\n      array.push(grid[row][0]);\n      grid[row][width].isWall = true;\n      array.push(grid[row][width]);\n    }\n  }\n  return array;\n}\n\nfunction addVerticalWall(grid, colStart, colEnd, colRandom, currentRow, array) {\n  getAllNodes(grid).forEach(node => {\n    if (node.row === currentRow && node.col !== colRandom && node.col >= colStart - 1 && node.col <= colEnd + 1) {\n      if (!node.isStart && !node.isFinish) {\n        node.isWall = true;\n        array.push(node);\n      }\n    }\n  });\n}\n\nfunction addHorizontalWall(grid, rowStart, rowEnd, rowRandom, currentCol, array) {\n  getAllNodes(grid).forEach(node => {\n    if (node.col === currentCol && node.row !== rowRandom && node.row >= rowStart - 1 && node.row <= rowEnd + 1) {\n      if (!node.isStart && !node.isFinish) {\n        node.isWall = true;\n        array.push(node);\n      }\n    }\n  });\n}\n\nfunction addInnerWalls(grid, rowStart, rowEnd, colStart, colEnd, orientation, array) {\n  if (orientation === 'horizontal') {\n    if (rowEnd < rowStart) {\n      return;\n    }\n\n    const [colRandom, currentRow] = randomColNRow(rowStart, rowEnd, colStart, colEnd, orientation);\n\n    addVerticalWall(grid, colStart, colEnd, colRandom, currentRow, array);\n\n    // check if remaining row from point or column is larger if # of rows from point is larger add another horizontal wall, else vertical wall\n    if (currentRow - 2 - rowStart > colEnd - colStart) {\n      addInnerWalls(grid, rowStart, currentRow - 2, colStart, colEnd, 'horizontal', array);\n    } else {\n      addInnerWalls(grid, rowStart, currentRow - 2, colStart, colEnd, 'vertical', array);\n    }\n    // check if remaining rows or column is larger if # of rows is larger add another horizontal wall, else vertical wall\n    if (rowEnd - (currentRow + 2) > colEnd - colStart) {\n      addInnerWalls(grid, currentRow + 2, rowEnd, colStart, colEnd, 'horizontal', array);\n    } else {\n      addInnerWalls(grid, currentRow + 2, rowEnd, colStart, colEnd, 'vertical', array);\n    }\n  } else if (orientation === 'vertical') {\n    if (colEnd < colStart) {\n      return;\n    }\n\n    let [currentCol, rowRandom] = randomColNRow(rowStart, rowEnd, colStart, colEnd, orientation);\n\n    addHorizontalWall(grid, rowStart, rowEnd, rowRandom, currentCol, array);\n\n    // check if remaining if either row or column is larger\n    if (rowEnd - rowStart > currentCol - 2 - colStart) {\n      addInnerWalls(grid, rowStart, rowEnd, colStart, currentCol - 2, 'horizontal', array);\n    } else {\n      addInnerWalls(grid, rowStart, rowEnd, colStart, currentCol - 2, 'vertical', array);\n    }\n    if (rowEnd - rowStart > colEnd - (currentCol + 2)) {\n      addInnerWalls(grid, rowStart, rowEnd, currentCol + 2, colEnd, 'horizontal', array);\n    } else {\n      addInnerWalls(grid, rowStart, rowEnd, currentCol + 2, colEnd, 'vertical', array);\n    }\n  }\n}\n\nexport default function recursiveDivision(grid) {\n  const wallsToAnimate = [];\n  addOuterWalls(grid, wallsToAnimate);\n  const row = grid.length;\n  const col = grid[0].length;\n  addInnerWalls(grid, 2, row - 3, 2, col - 3, 'horizontal', wallsToAnimate);\n  return wallsToAnimate;\n}\n","function randomNumber(array) {\n  return Math.floor(Math.random() * array.length);\n}\n\nfunction randomColNRow(rowStart, rowEnd, colStart, colEnd, orientation) {\n  const possibleCols = [];\n  const possibleRows = [];\n  if (orientation === 'horizontal') {\n    // walls on even cells only\n    for (let number = rowStart; number <= rowEnd; number += 2) {\n      possibleRows.push(number);\n    }\n    // openings in odd cells only\n    for (let number = colStart - 1; number <= colEnd + 1; number += 2) {\n      possibleCols.push(number);\n    }\n  } else {\n    for (let number = colStart; number <= colEnd; number += 2) {\n      possibleCols.push(number);\n    }\n    for (let number = rowStart - 1; number <= rowEnd + 1; number += 2) {\n      possibleRows.push(number);\n    }\n  }\n  const randomColIndex = randomNumber(possibleCols);\n  const randomRowIndex = randomNumber(possibleRows);\n  const colRandom = possibleCols[randomColIndex];\n  const rowRandom = possibleRows[randomRowIndex];\n  return [colRandom, rowRandom];\n}\n\nconst getAllNodes = function(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n};\n\nfunction addOuterWalls(grid, array) {\n  const width = grid[0].length - 1;\n  const height = grid.length - 1;\n  for (let row = 0; row < grid.length; row++) {\n    if (row === 0 || row === height) {\n      for (let col = 0; col <= width; col++) {\n        const node = grid[row][col];\n        node.isWall = true;\n        array.push(node);\n      }\n    } else {\n      grid[row][0].isWall = true;\n      array.push(grid[row][0]);\n      grid[row][width].isWall = true;\n      array.push(grid[row][width]);\n    }\n  }\n  return array;\n}\n\nfunction addVerticalWall(grid, colStart, colEnd, colRandom, currentRow, array) {\n  getAllNodes(grid).forEach(node => {\n    if (node.row === currentRow && node.col !== colRandom && node.col >= colStart - 1 && node.col <= colEnd + 1) {\n      if (!node.isStart && !node.isFinish) {\n        node.isWall = true;\n        array.push(node);\n      }\n    }\n  });\n}\n\nfunction addHorizontalWall(grid, rowStart, rowEnd, rowRandom, currentCol, array) {\n  getAllNodes(grid).forEach(node => {\n    if (node.col === currentCol && node.row !== rowRandom && node.row >= rowStart - 1 && node.row <= rowEnd + 1) {\n      if (!node.isStart && !node.isFinish) {\n        node.isWall = true;\n        array.push(node);\n      }\n    }\n  });\n}\n\nfunction addInnerWalls(grid, rowStart, rowEnd, colStart, colEnd, orientation, array) {\n  if (orientation === 'horizontal') {\n    if (rowEnd < rowStart) {\n      return;\n    }\n\n    const [colRandom, currentRow] = randomColNRow(rowStart, rowEnd, colStart, colEnd, orientation);\n\n    addVerticalWall(grid, colStart, colEnd, colRandom, currentRow, array);\n\n    // check if remaining row from point or column is larger if # of rows from point is larger add another horizontal wall, else vertical wall\n    if (currentRow - 2 - rowStart > colEnd - colStart) {\n      addInnerWalls(grid, rowStart, currentRow - 2, colStart, colEnd, 'horizontal', array);\n    } else {\n      addInnerWalls(grid, rowStart, currentRow - 2, colStart, colEnd, 'vertical', array);\n    }\n    // check if remaining rows or column is larger if # of rows is larger add another horizontal wall, else vertical wall\n    if (rowEnd - (currentRow + 2) > colEnd - colStart) {\n      addInnerWalls(grid, currentRow + 2, rowEnd, colStart, colEnd, 'vertical', array);\n    } else {\n      addInnerWalls(grid, currentRow + 2, rowEnd, colStart, colEnd, 'vertical', array);\n    }\n  } else if (orientation === 'vertical') {\n    if (colEnd < colStart) {\n      return;\n    }\n\n    let [currentCol, rowRandom] = randomColNRow(rowStart, rowEnd, colStart, colEnd, orientation);\n\n    addHorizontalWall(grid, rowStart, rowEnd, rowRandom, currentCol, array);\n\n    // check if remaining if either row or column is larger\n    if (rowEnd - rowStart > currentCol - 2 - colStart) {\n      addInnerWalls(grid, rowStart, rowEnd, colStart, currentCol - 2, 'vertical', array);\n    } else {\n      addInnerWalls(grid, rowStart, rowEnd, colStart, currentCol - 2, 'vertical', array);\n    }\n    if (rowEnd - rowStart > colEnd - (currentCol + 2)) {\n      addInnerWalls(grid, rowStart, rowEnd, currentCol + 2, colEnd, 'horizontal', array);\n    } else {\n      addInnerWalls(grid, rowStart, rowEnd, currentCol + 2, colEnd, 'vertical', array);\n    }\n  }\n}\n\nexport default function recursiveVertical(grid) {\n  const wallsToAnimate = [];\n  addOuterWalls(grid, wallsToAnimate);\n  const row = grid.length;\n  const col = grid[0].length;\n  addInnerWalls(grid, 2, row - 3, 2, col - 3, 'horizontal', wallsToAnimate);\n  return wallsToAnimate;\n}\n","function randomNumber(array) {\n  return Math.floor(Math.random() * array.length);\n}\n\nfunction randomColNRow(rowStart, rowEnd, colStart, colEnd, orientation) {\n  const possibleCols = [];\n  const possibleRows = [];\n  if (orientation === 'horizontal') {\n    // walls on even cells only\n    for (let number = rowStart; number <= rowEnd; number += 2) {\n      possibleRows.push(number);\n    }\n    // openings in odd cells only\n    for (let number = colStart - 1; number <= colEnd + 1; number += 2) {\n      possibleCols.push(number);\n    }\n  } else {\n    for (let number = colStart; number <= colEnd; number += 2) {\n      possibleCols.push(number);\n    }\n    for (let number = rowStart - 1; number <= rowEnd + 1; number += 2) {\n      possibleRows.push(number);\n    }\n  }\n  const randomColIndex = randomNumber(possibleCols);\n  const randomRowIndex = randomNumber(possibleRows);\n  const colRandom = possibleCols[randomColIndex];\n  const rowRandom = possibleRows[randomRowIndex];\n  return [colRandom, rowRandom];\n}\n\nconst getAllNodes = function(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n};\n\nfunction addOuterWalls(grid, array) {\n  const width = grid[0].length - 1;\n  const height = grid.length - 1;\n  for (let row = 0; row < grid.length; row++) {\n    if (row === 0 || row === height) {\n      for (let col = 0; col <= width; col++) {\n        const node = grid[row][col];\n        node.isWall = true;\n        array.push(node);\n      }\n    } else {\n      grid[row][0].isWall = true;\n      array.push(grid[row][0]);\n      grid[row][width].isWall = true;\n      array.push(grid[row][width]);\n    }\n  }\n  return array;\n}\n\nfunction addVerticalWall(grid, colStart, colEnd, colRandom, currentRow, array) {\n  getAllNodes(grid).forEach(node => {\n    if (node.row === currentRow && node.col !== colRandom && node.col >= colStart - 1 && node.col <= colEnd + 1) {\n      if (!node.isStart && !node.isFinish) {\n        node.isWall = true;\n        array.push(node);\n      }\n    }\n  });\n}\n\nfunction addHorizontalWall(grid, rowStart, rowEnd, rowRandom, currentCol, array) {\n  getAllNodes(grid).forEach(node => {\n    if (node.col === currentCol && node.row !== rowRandom && node.row >= rowStart - 1 && node.row <= rowEnd + 1) {\n      if (!node.isStart && !node.isFinish) {\n        node.isWall = true;\n        array.push(node);\n      }\n    }\n  });\n}\n\nfunction addInnerWalls(grid, rowStart, rowEnd, colStart, colEnd, orientation, array) {\n  if (orientation === 'horizontal') {\n    if (rowEnd < rowStart) {\n      return;\n    }\n\n    const [colRandom, currentRow] = randomColNRow(rowStart, rowEnd, colStart, colEnd, orientation);\n\n    addVerticalWall(grid, colStart, colEnd, colRandom, currentRow, array);\n\n    // check if remaining row from point or column is larger if # of rows from point is larger add another horizontal wall, else vertical wall\n    if (currentRow - 2 - rowStart > colEnd - colStart) {\n      addInnerWalls(grid, rowStart, currentRow - 2, colStart, colEnd, 'horizontal', array);\n    } else {\n      addInnerWalls(grid, rowStart, currentRow - 2, colStart, colEnd, 'horizontal', array);\n    }\n    // check if remaining rows or column is larger if # of rows is larger add another horizontal wall, else vertical wall\n    if (rowEnd - (currentRow + 2) > colEnd - colStart) {\n      addInnerWalls(grid, currentRow + 2, rowEnd, colStart, colEnd, 'horizontal', array);\n    } else {\n      addInnerWalls(grid, currentRow + 2, rowEnd, colStart, colEnd, 'vertical', array);\n    }\n  } else if (orientation === 'vertical') {\n    if (colEnd < colStart) {\n      return;\n    }\n\n    let [currentCol, rowRandom] = randomColNRow(rowStart, rowEnd, colStart, colEnd, orientation);\n\n    addHorizontalWall(grid, rowStart, rowEnd, rowRandom, currentCol, array);\n\n    // check if remaining if either row or column is larger\n    if (rowEnd - rowStart > currentCol - 2 - colStart) {\n      addInnerWalls(grid, rowStart, rowEnd, colStart, currentCol - 2, 'horizontal', array);\n    } else {\n      addInnerWalls(grid, rowStart, rowEnd, colStart, currentCol - 2, 'horizontal', array);\n    }\n    if (rowEnd - rowStart > colEnd - (currentCol + 2)) {\n      addInnerWalls(grid, rowStart, rowEnd, currentCol + 2, colEnd, 'horizontal', array);\n    } else {\n      addInnerWalls(grid, rowStart, rowEnd, currentCol + 2, colEnd, 'vertical', array);\n    }\n  }\n}\n\nexport default function recursiveVertical(grid) {\n  const wallsToAnimate = [];\n  addOuterWalls(grid, wallsToAnimate);\n  const row = grid.length;\n  const col = grid[0].length;\n  addInnerWalls(grid, 2, row - 3, 2, col - 3, 'horizontal', wallsToAnimate);\n  return wallsToAnimate;\n}\n","import React, { useState, useEffect, useContext } from 'react';\nimport Node from './Node';\nimport NavBar from './NavBar';\nimport Legend from './Legend';\nimport { dijkstra, getNodesInShortestPathOrder, dfs, bfs, bestfs, astar, getBiDirectionalShortestPath, bi_bfs } from '../algorithms/index';\nimport { pathfindingContext } from '../context/pathfindingContext';\nimport { basicRandom, recursiveDivision, recursiveVertical, recursiveHorizontal } from '../maze-algorithms/index';\n\nimport './PathfindingVisualizer.scss';\n\nconst nodesToUpdate = [];\n\nconst createNode = function(col, row, startNode, finishNode) {\n  return {\n    id: `${row}-${col}`,\n    col,\n    row,\n    isStart: row === startNode.row && col === startNode.col,\n    isFinish: row === finishNode.row && col === finishNode.col,\n    distance: Infinity,\n    biDistance: Infinity,\n    totalDistance: Infinity,\n    heuristicDistance: null,\n    isVisited: false,\n    isWall: false,\n    previousNode: null,\n    biPreviousNode: null,\n    weight: 0,\n  };\n};\n\nfunction resetNode(node) {\n  return {\n    ...node,\n    distance: Infinity,\n    totalDistance: Infinity,\n    heuristicDistance: null,\n    isVisited: false,\n    isWall: false,\n    previousNode: null,\n    weight: 0,\n  };\n}\n\nconst getInitialGrid = function(startNode, finishNode) {\n  const grid = [];\n  // best size is row 31 col 78\n  for (let row = 0; row < 31; row++) {\n    const currentRow = [];\n    for (let col = 0; col < 78; col++) {\n      currentRow.push(createNode(col, row, startNode, finishNode));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\n// const getNewGridWithWallToggled = function(grid, row, col) {\n//   /* preformance issues - too many rerenders*/\n//   // const newGrid = grid.slice();\n//   // const node = newGrid[row][col];\n//   // const newNode = {\n//   //   ...node,\n//   //   isWall: !node.isWall,\n//   // };\n//   // // update the newNode\n//   // newGrid[row][col] = newNode;\n//   // return newGrid;\n// };\n\nconst dragEnterNode = function(grid, row, col, type, array = null) {\n  const node = grid[row][col];\n  switch (type) {\n    case 'START':\n      document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-start';\n      break;\n    case 'END':\n      document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-finish';\n      break;\n    case 'WALL':\n      /* Hacky Solution for now */\n      // const newNode = {\n      //   ...node,\n      //   isWall: !node.isWall,\n      // };\n      // grid[row][col] = newNode;\n\n      if (node.isStart || node.isFinish) return;\n      /* changed to batch update wall Nodes */\n      const newNode = { ...node, isWall: !node.isWall };\n      array.push(newNode);\n\n      document.getElementById(`node-${node.row}-${node.col}`).className = node.isWall ? 'node' : 'node-wall';\n      break;\n    default:\n      console.log('not a predefined case');\n      return;\n  }\n};\n\nconst dragLeaveNode = function(grid, row, col) {\n  const node = grid[row][col];\n  if (node.isWall) {\n    document.getElementById(`node-${node.row}-${node.col}`).className = 'node-wall';\n  } else {\n    document.getElementById(`node-${node.row}-${node.col}`).className = 'node node';\n  }\n};\n\nconst setNode = function(grid, row, col, type) {\n  const node = grid[row][col];\n  let newNode = {};\n  switch (type) {\n    case 'START':\n      newNode = {\n        ...node,\n        isStart: !node.isStart,\n      };\n      grid[row][col] = newNode;\n      document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-start';\n      break;\n    case 'END':\n      newNode = {\n        ...node,\n        isFinish: !node.isFinish,\n      };\n      grid[row][col] = newNode;\n      document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-finish';\n      break;\n    default:\n      console.log('not a predefined case');\n      return;\n  }\n};\n\nconst updatedGridWithWalls = function(grid, nodesToUpdate) {\n  // Manually Batch Update Wall Nodes\n  const newGrid = grid.slice();\n  nodesToUpdate.forEach(node => {\n    newGrid[node.row][node.col] = node;\n  });\n  return newGrid;\n};\n\nexport default function PathfindingVisualizer(props) {\n  // console.log('RENDERING GRID');\n  const [grid, setGrid] = useState([]);\n  const [mouseIsPressed, setMouseIsPressed] = useState(false);\n  const { state, dispatch } = useContext(pathfindingContext);\n\n  const START_NODE = state.startNode;\n  const END_NODE = state.endNode;\n\n  useEffect(() => {\n    const grid = getInitialGrid(START_NODE, END_NODE);\n    setGrid(grid);\n  }, []);\n\n  return (\n    <div id='pathfinding-visualizer'>\n      <NavBar visualizeClick={visualizePath} mazeClick={visualizeMaze} resetClick={resetGrid} clearClick={clearPath} />\n      <Legend />\n      <div className='grid'>{renderGrid(grid)}</div>\n    </div>\n  );\n\n  function renderGrid(grid) {\n    return grid.map((row, rowIdx) => {\n      return (\n        <div key={rowIdx} className='grid-row'>\n          {row.map((node, nodeIdx) => {\n            const { row, col, isFinish, isStart, isWall, distance, totalDistance } = node;\n            return (\n              <Node\n                key={nodeIdx}\n                col={col}\n                isFinish={isFinish}\n                isStart={isStart}\n                isWall={isWall}\n                onMouseDown={(row, col) => handleMouseDown(row, col)}\n                onMouseEnter={(row, col) => handleMouseEnter(row, col)}\n                onMouseLeave={(row, col) => handleMouseLeave(row, col)}\n                onMouseUp={(row, col) => handleMouseUp(row, col)}\n                row={row}\n                showNumbers={state.showNumbers}\n                distance={distance}\n                totalDistance={totalDistance}></Node>\n            );\n          })}\n        </div>\n      );\n    });\n  }\n\n  function handleMouseDown(row, col) {\n    if (grid[row][col].isStart) {\n      // setMovingStart(true);\n      setMouseIsPressed('START');\n      dragEnterNode(grid, row, col, 'START');\n    } else if (grid[row][col].isFinish) {\n      // setMovingEnd(true);\n      setMouseIsPressed('END');\n      dragEnterNode(grid, row, col, 'END');\n    } else {\n      // setMouseIsPressed(true);\n      setMouseIsPressed('WALL');\n      dragEnterNode(grid, row, col, 'WALL', nodesToUpdate);\n    }\n  }\n\n  function handleMouseEnter(row, col) {\n    if (mouseIsPressed === 'START') dragEnterNode(grid, row, col, 'START');\n    if (mouseIsPressed === 'END') dragEnterNode(grid, row, col, 'END');\n    if (mouseIsPressed === 'WALL') dragEnterNode(grid, row, col, 'WALL', nodesToUpdate);\n  }\n\n  function handleMouseLeave(row, col) {\n    if (mouseIsPressed === 'START' || mouseIsPressed === 'END') {\n      dragLeaveNode(grid, row, col);\n    }\n  }\n\n  function handleMouseUp(row, col) {\n    if (mouseIsPressed === 'START') {\n      setNode(grid, row, col, 'START');\n      dispatch({ type: 'SET_START_NODE', payload: { row, col } });\n    }\n\n    if (mouseIsPressed === 'END') {\n      setNode(grid, row, col, 'END');\n      dispatch({ type: 'SET_END_NODE', payload: { row, col } });\n    }\n\n    if (mouseIsPressed === 'WALL') {\n      // ensures render of grid\n      const newGrid = updatedGridWithWalls(grid, nodesToUpdate);\n      // clear queue\n      nodesToUpdate.length = 0;\n      setGrid(newGrid);\n    }\n\n    setMouseIsPressed(false);\n    // setMovingStart(false);\n    // setMovingEnd(false);\n  }\n\n  function animatePath(visitedNodesInOrder, nodesInShortestPathOrder) {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          animateShortestPath(nodesInShortestPathOrder);\n        }, state.speed.visited * i);\n        // optimal 10\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        // hacky solution to minimize rerenders\n        // TODO: look into useRef to achieve similar result\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited';\n      }, state.speed.visited * i);\n      // optimal 10\n    }\n  }\n\n  function animateShortestPath(nodesInShortestPathOrder) {\n    for (let i = 0; i <= nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-shortest-path';\n      }, state.speed.shortestPath * i);\n      // optimal 50\n    }\n  }\n\n  function setAlgorithm(algorithm, grid, startNode, endNode) {\n    switch (algorithm) {\n      case 'DJISKTRA':\n        return dijkstra(grid, startNode, endNode);\n      case 'BREADTH_FIRST_SEARCH':\n        return bfs(grid, startNode, endNode);\n      case 'DEPTH_FIRST_SEARCH':\n        return dfs(grid, startNode, endNode);\n      case 'BEST_FIRST_SEARCH':\n        return bestfs(grid, startNode, endNode);\n      case 'A_STAR':\n        return astar(grid, startNode, endNode);\n      case 'BI_DIRECTIONAL_BFS':\n        return bi_bfs(grid, startNode, endNode);\n      default:\n        console.log('UNIMPLEMENTED ALGORITHM \\n DEFAULT SET TO DJISKTRA');\n        return dijkstra(grid, startNode, endNode);\n    }\n  }\n\n  function visualizePath() {\n    const startNode = grid[state.startNode.row][state.startNode.col];\n    const endNode = grid[state.endNode.row][state.endNode.col];\n    let visitedNodesInOrder;\n    let middleNode;\n    let nodesInShortestPathOrder;\n    if (state.currentAlgorithm === 'BI_DIRECTIONAL_BFS') {\n      [visitedNodesInOrder, middleNode] = setAlgorithm(state.currentAlgorithm, grid, startNode, endNode);\n      nodesInShortestPathOrder = getBiDirectionalShortestPath(middleNode);\n    } else {\n      visitedNodesInOrder = setAlgorithm(state.currentAlgorithm, grid, startNode, endNode);\n      nodesInShortestPathOrder = getNodesInShortestPathOrder(endNode);\n    }\n    animatePath(visitedNodesInOrder, nodesInShortestPathOrder);\n  }\n\n  function visualizeMaze(maze) {\n    let wallNodesInOrder;\n\n    switch (maze) {\n      case 'RECURSIVE_DIVISION':\n        wallNodesInOrder = recursiveDivision(grid);\n        break;\n      case 'BASIC_RANDOM':\n        wallNodesInOrder = basicRandom(grid);\n        break;\n      case 'RECURSIVE_VERTICAL':\n        wallNodesInOrder = recursiveVertical(grid);\n        break;\n      case 'RECURSIVE_HORIZONTAL':\n        wallNodesInOrder = recursiveHorizontal(grid);\n        break;\n      default:\n        wallNodesInOrder = recursiveDivision(grid);\n        break;\n    }\n    animateMaze(wallNodesInOrder);\n  }\n\n  function animateMaze(visitedNodesInOrder) {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        // hacky solution to minimize rerenders\n        // TODO: look into useRef to achieve similar result\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node-wall';\n      }, 10 * i);\n    }\n  }\n\n  function resetGrid() {\n    const newGrid = grid.slice();\n    for (let row = 0; row < newGrid.length; row++) {\n      for (let col = 0; col < newGrid[row].length; col++) {\n        if (grid[row][col].isStart) {\n          const node = grid[row][col];\n          const newNode = resetNode(node);\n          grid[row][col] = newNode;\n          document.getElementById(`node-${row}-${col}`).className = 'node node-start';\n          continue;\n        }\n        if (grid[row][col].isFinish) {\n          const node = grid[row][col];\n          const newNode = resetNode(node);\n          grid[row][col] = newNode;\n          document.getElementById(`node-${row}-${col}`).className = 'node node-finish';\n          continue;\n        }\n        const node = grid[row][col];\n        const newNode = resetNode(node);\n        grid[row][col] = newNode;\n        document.getElementById(`node-${row}-${col}`).className = 'node';\n      }\n    }\n    setGrid(newGrid);\n  }\n\n  function clearPath() {\n    const newGrid = grid.slice();\n    for (let row = 0; row < newGrid.length; row++) {\n      for (let col = 0; col < newGrid[row].length; col++) {\n        const node = grid[row][col];\n        let newNode = resetNode(node);\n        if (node.isWall) {\n          newNode = { ...newNode, isWall: true };\n        }\n        grid[row][col] = newNode;\n        if (newNode.isStart) {\n          document.getElementById(`node-${row}-${col}`).className = 'node node-start';\n          continue;\n        } else if (newNode.isFinish) {\n          document.getElementById(`node-${row}-${col}`).className = 'node node-finish';\n          continue;\n        } else if (newNode.isWall) {\n          document.getElementById(`node-${row}-${col}`).className = 'node-wall';\n        } else {\n          document.getElementById(`node-${row}-${col}`).className = 'node';\n        }\n      }\n    }\n    setGrid(newGrid);\n  }\n}\n","export default function basicRandom(grid) {\n  const wallsToAnimate = [];\n  let currentY = grid[0].length - 10;\n  for (let i = 0; i < 20; i++) {\n    for (let counter = 0; counter < 15; counter++) {\n      currentY = Math.floor(Math.random() * grid[0].length);\n      const currentXOne = Math.floor(grid.length / 2) - counter;\n      const currentXTwo = Math.floor(grid.length / 2) + counter;\n      const currentNodeOne = grid[currentXOne][currentY];\n      const currentNodeTwo = grid[currentXTwo][currentY];\n      if (currentNodeOne.isStart || currentNodeOne.isFinish) continue;\n      if (currentNodeTwo.isStart || currentNodeTwo.isFinish) continue;\n\n      wallsToAnimate.push(currentNodeOne);\n      wallsToAnimate.push(currentNodeTwo);\n      currentNodeOne.isWall = true;\n      currentNodeTwo.isWall = true;\n    }\n  }\n  return wallsToAnimate;\n}\n","const getUnvisitedNeighbors = function(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n};\n\nexport function bfs(grid, startNode, finishNode) {\n  const unvisitedNodes = [startNode];\n  let exploredNodes = { [startNode.id]: true };\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n\n  while (unvisitedNodes.length) {\n    let currentNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (currentNode.isWall) continue;\n\n    // If the closest node is a distance of ifinity,\n    // we must be trapped and should therefore stop.\n\n    if (currentNode.distance === Infinity) return visitedNodesInOrder;\n\n    if (currentNode === finishNode) return visitedNodesInOrder;\n    currentNode.isVisited = true;\n    visitedNodesInOrder.push(currentNode);\n    const currentNeighbors = getUnvisitedNeighbors(currentNode, grid);\n    currentNeighbors.forEach(neighbor => {\n      if (!exploredNodes[neighbor.id]) {\n        exploredNodes[neighbor.id] = true;\n        neighbor.distance = currentNode.distance + 1;\n        neighbor.previousNode = currentNode;\n        unvisitedNodes.push(neighbor);\n      }\n    });\n  }\n  return -1;\n}\n","const getUnvisitedNeighbors = function(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.unshift(grid[row - 1][col]);\n  if (col < grid[0].length - 1) neighbors.unshift(grid[row][col + 1]);\n  if (row < grid.length - 1) neighbors.unshift(grid[row + 1][col]);\n  if (col > 0) neighbors.unshift(grid[row][col - 1]);\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n};\n\nexport function dfs(grid, startNode, finishNode) {\n  const unvisitedNodes = [startNode];\n  let exploredNodes = { [startNode.id]: true };\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n\n  while (unvisitedNodes.length) {\n    let currentNode = unvisitedNodes.pop();\n    exploredNodes[currentNode.id] = true;\n    // If we encounter a wall, we skip it.\n    if (currentNode.isWall) continue;\n\n    // If the closest node is a distance of ifinity,\n    // we must be trapped and should therefore stop.\n\n    // if (currentNode.distance === Infinity) return visitedNodesInOrder;\n\n    if (currentNode === finishNode) return visitedNodesInOrder;\n    currentNode.isVisited = true;\n    visitedNodesInOrder.push(currentNode);\n    const currentNeighbors = getUnvisitedNeighbors(currentNode, grid);\n    currentNeighbors.forEach(neighbor => {\n      if (!exploredNodes[neighbor.id]) {\n        neighbor.distance = currentNode.distance + 1;\n        neighbor.previousNode = currentNode;\n        unvisitedNodes.push(neighbor);\n      }\n    });\n  }\n  return -1;\n}\n","import React from 'react';\nimport PathfindingVisualizer from './components/PathfindingVisualizer';\nimport './custom.scss';\nimport './App.scss';\n\nimport PathfindingContextProvider from './context/pathfindingContext';\n\nconst App = function() {\n  return (\n    <div className='App'>\n      <PathfindingContextProvider>\n        <PathfindingVisualizer></PathfindingVisualizer>\n      </PathfindingContextProvider>\n    </div>\n  );\n};\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}