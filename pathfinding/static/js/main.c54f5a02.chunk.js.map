{"version":3,"sources":["imgs/logo.svg","imgs/start.png","imgs/end.png","components/Node.jsx","context/pathfindingContext.jsx","components/NavBar.jsx","components/Legend.jsx","algorithms/dijsktra.js","algorithms/bi-directional-bfs.js","algorithms/best-first-search.js","algorithms/astar.js","maze-algorithms/recursiveDivision.js","maze-algorithms/recursiveVertical.js","maze-algorithms/recursiveHorizontal.js","components/PathfindingVisualizer.jsx","maze-algorithms/basicRandom.js","algorithms/bfs.js","algorithms/dfs.js","App.jsx","index.js"],"names":["module","exports","Node","props","row","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseLeave","onMouseUp","distance","totalDistance","showNumbers","extraClassName","id","className","Infinity","pathfindingContext","createContext","pathfindingReducer","state","action","type","currentAlgorithm","payload","currentMaze","startNode","endNode","speed","initialState","visited","shortestPath","PathfindingContextProvider","useReducer","dispatch","Provider","value","children","pathfindingAlgorithms","Djisktra","mazeAlgorithms","speeds","Fast","Average","Slow","NavBar","console","log","useState","algorithm","setAlgorithm","setSpeed","useContext","Navbar","bg","variant","Brand","src","Logo","width","height","alt","Toggle","aria-controls","Collapse","Nav","fill","NavDropdown","title","Object","keys","map","Item","key","onClick","e","maze","mazeClick","Button","visualizeClick","Link","resetClick","clearClick","Legend","StartImg","EndImg","dijkstra","grid","finishNode","visitedNodesInOrder","unvisitedNodes","getAllNodes","length","sortNodesByDistance","closestNode","shift","isVisited","push","updateUnvisitedNeighbors","sort","nodeA","nodeB","node","unvisitedNeighbors","getUnvisitedNeighbors","neighbor","previousNode","neighbors","filter","nodes","bi_bfs","unvisitedNodesStart","unvisitedNodesFinish","exploredNodesStart","exploredNodesFinish","biDistance","startingCurrentNode","finishCurrentNode","forEach","biPreviousNode","_bi_bfs","middleNode","updateNode","distanceFromNeighbor","distanceToCompare","weight","targetNode","yChange","Math","abs","manhattanDistance","bestfs","heuristicDistance","astar","randomNumber","array","floor","random","randomColNRow","rowStart","rowEnd","colStart","colEnd","orientation","possibleCols","possibleRows","number","randomColIndex","randomRowIndex","addInnerWalls","colRandom","currentRow","addVerticalWall","currentCol","rowRandom","addHorizontalWall","recursiveDivision","wallsToAnimate","addOuterWalls","nodesToUpdate","createNode","resetNode","dragEnterNode","document","getElementById","newNode","setNode","PathfindingVisualizer","setGrid","mouseIsPressed","setMouseIsPressed","START_NODE","END_NODE","useEffect","getInitialGrid","nodesInShortestPathOrder","fromStart","fromFinish","toStart","toEnd","reverse","concat","getBiDirectionalShortestPath","getNodesInShortestPathOrder","currentNode","unshift","i","setTimeout","animateShortestPath","animatePath","wallNodesInOrder","currentY","counter","currentXOne","currentXTwo","currentNodeOne","currentNodeTwo","basicRandom","recursiveVertical","recursiveHorizontal","animateMaze","newGrid","slice","rowIdx","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseLeave","handleMouseUp","renderGrid","dragLeaveNode","updatedGridWithWalls","exploredNodes","bfs","pop","dfs","App","ReactDOM","render"],"mappings":"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","file":"static/js/main.c54f5a02.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.13cfaeef.svg\";","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAABmJLR0QA/wD/AP+gvaeTAAAAqElEQVQ4jb3SuwrCQBCF4R+vnS8kCRYaBR/P1s7GS8RCzYt5bSQ2WZQwATmzeGC75WNmOPDHjIAl0IuBpcAFKIEC6HuwBLhVWHgHoKuCQwMsgb0HTfisHA1NgauB5kBHRSfA3UB3XvRhoFsPOmtAV/WPrR/BVwXUM1Cmy7DveEYo/BR71ZOCNd3tGBPLEYqdAU8Dk2syNsC1ioV8r7zxYiFzYAG0Y2By3qkYVGYp61DuAAAAAElFTkSuQmCC\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASCAYAAABWzo5XAAAABmJLR0QA/wD/AP+gvaeTAAAA8klEQVQ4jaXUP0oDQRgF8J+rRBBFK7W28E+vHsCLWAXvI1hok3iKVIEcwDMIWigIgr3uapHZMG52dgfy4GvevO/N92Zml37c4bZPtJFhdJShUXSsbbdw+ynxeoI/xSvecRa4LcwwwVvviAEFRqjwGaoKXFeKBU4iYW32G2rUWDtOmezip6VhHKq5wTd2UmbDlgibGDRMqqBdYA33/l/xOfbwiBtMA3+FB1zjC09Rz3Nhnn9VLHm0RRvIiBbjEKX8wy5xkDK7bGlIXf9FyiTGyg8ynqw0P4dJqGHgsiaJUX+gtVHMLaFrzI9MDnn/oxcZb+0PHO87YnWK2NgAAAAASUVORK5CYII=\"","import React from 'react';\nimport './Node.scss';\n\nfunction Node(props) {\n  // console.log('RENDERING NODE');\n  const {\n    row,\n    col,\n    isFinish,\n    isStart,\n    isWall,\n    onMouseDown,\n    onMouseEnter,\n    onMouseLeave,\n    onMouseUp,\n    distance,\n    totalDistance,\n    showNumbers,\n  } = props;\n  const extraClassName = isFinish ? 'node-finish' : isStart ? 'node-start' : isWall ? 'node-wall' : '';\n\n  return (\n    <div\n      id={`node-${row}-${col}`}\n      className={`node ${extraClassName}`}\n      onMouseDown={() => onMouseDown(row, col)}\n      onMouseEnter={() => onMouseEnter(row, col)}\n      onMouseLeave={() => onMouseLeave(row, col)}\n      onMouseUp={() => onMouseUp(row, col)}>\n      {showNumbers && (\n        <span className='node-distance'>{distance !== Infinity && (totalDistance !== Infinity ? totalDistance : distance)}</span>\n      )}\n    </div>\n  );\n}\n\nexport default Node;\n// export default React.memo(Node);\n","import React, { createContext, useReducer } from 'react';\nexport const pathfindingContext = createContext();\n\nconst speed = {\n  Fast: { visited: 10, shortestPath: 50 },\n  Average: { visited: 40, shortestPath: 75 },\n  Slow: { visited: 70, shortestPath: 100 },\n};\n\nconst pathfindingReducer = (state, action) => {\n  switch (action.type) {\n    case 'SET_ALGORITHM':\n      return { ...state, currentAlgorithm: action.payload };\n    case 'SET_MAZE':\n      return { ...state, currentMaze: action.payload };\n    case 'SET_START_NODE':\n      return { ...state, startNode: action.payload };\n    case 'SET_END_NODE':\n      return { ...state, endNode: action.payload };\n    case 'SET_SPEED':\n      return { ...state, speed: action.payload };\n    case 'TOGGLE_NUMBERS':\n      return { ...state, showNumbers: !state.showNumbers };\n    default:\n      return state;\n  }\n};\nconst initialState = {\n  startNode: { row: 15, col: 15 },\n  endNode: { row: 15, col: 55 },\n  currentAlgorithm: 'DEPTH_FIRST_SEARCH',\n  currentMaze: 'RECURSIVE_DIVISION',\n  speed: speed.Fast,\n  showNumbers: false,\n};\n\nexport default function PathfindingContextProvider(props) {\n  const [state, dispatch] = useReducer(pathfindingReducer, initialState);\n\n  return <pathfindingContext.Provider value={{ state, dispatch }}>{props.children}</pathfindingContext.Provider>;\n}\n","import React, { useContext, useState } from 'react';\nimport { Navbar, Nav, NavDropdown, Button } from 'react-bootstrap';\nimport { pathfindingContext } from '../context/pathfindingContext';\nimport Logo from '../imgs/logo.svg';\nimport './NavBar.scss';\n\nconst pathfindingAlgorithms = {\n  'Depth First Search': 'DEPTH_FIRST_SEARCH',\n  'Breadth First Search': 'BREADTH_FIRST_SEARCH',\n  'Greedy Best Search': 'BEST_FIRST_SEARCH',\n  Djisktra: 'DJISKTRA',\n  'A*': 'A_STAR',\n  // 'Bi Directional BFS': 'BI_DIRECTIONAL_BFS',\n};\n\nconst mazeAlgorithms = {\n  'Recursive Division': 'RECURSIVE_DIVISION',\n  'Basic Random': 'BASIC_RANDOM',\n  'Recursive Vertical Bias': 'RECURSIVE_VERTICAL',\n  'Recursive Horizontal Bias': 'RECURSIVE_HORIZONTAL',\n};\n\nconst speeds = {\n  Fast: { visited: 10, shortestPath: 50 },\n  Average: { visited: 40, shortestPath: 75 },\n  Slow: { visited: 70, shortestPath: 100 },\n};\n\nexport default function NavBar(props) {\n  console.log('RENDERING NAVBAR');\n  const [algorithm, setAlgorithm] = useState('Depth First Search');\n  const [speed, setSpeed] = useState('');\n  const { state, dispatch } = useContext(pathfindingContext);\n\n  function handleAlgorithm(value) {\n    setAlgorithm(value);\n    dispatch({ type: 'SET_ALGORITHM', payload: pathfindingAlgorithms[value] });\n  }\n\n  function handleMaze(value) {\n    props.mazeClick(value);\n    // dispatch({ type: 'SET_MAZE', payload: value });\n  }\n\n  function handleSpeed(value) {\n    setSpeed(value);\n    dispatch({ type: 'SET_SPEED', payload: speeds[value] });\n  }\n\n  function handleToggle(value) {\n    dispatch({ type: 'TOGGLE_NUMBERS' });\n  }\n\n  return (\n    <Navbar bg='dark' variant='dark'>\n      <Navbar.Brand>\n        <img src={Logo} width='35' height='35' alt='Pathfinding Visualizer Logo'></img>\n        <span className='navbar-brand-text'>PathFinding Visualizer</span>\n      </Navbar.Brand>\n      <Navbar.Toggle aria-controls='navbar-nav' />\n      <Navbar.Collapse id='navbar-nav'>\n        <Nav fill className='mr-auto'>\n          <NavDropdown title='Algorithms' id='algorithms-nav-dropdown'>\n            {Object.keys(pathfindingAlgorithms).map(algorithm => (\n              <NavDropdown.Item key={algorithm} onClick={e => handleAlgorithm(algorithm)}>\n                {algorithm}\n              </NavDropdown.Item>\n            ))}\n          </NavDropdown>\n          <NavDropdown title='Maze & Patterns' id='maze-nav-dropdown'>\n            {Object.keys(mazeAlgorithms).map(maze => (\n              <NavDropdown.Item key={maze} onClick={() => handleMaze(mazeAlgorithms[maze])}>\n                {maze}\n              </NavDropdown.Item>\n            ))}\n          </NavDropdown>\n          <Nav.Item>\n            <Button variant='primary' onClick={props.visualizeClick}>\n              Visualize {algorithm}\n            </Button>\n          </Nav.Item>\n          <Nav.Link onClick={props.resetClick}>Clear Board</Nav.Link>\n          <Nav.Link onClick={props.clearClick}>Clear Path</Nav.Link>\n        </Nav>\n        <NavDropdown title={`Speed${speed ? ': ' + speed : ''}`} id='speed-nav-dropdown'>\n          {Object.keys(speeds).map(speed => (\n            <NavDropdown.Item key={speed} onClick={() => handleSpeed(speed)}>\n              {speed}\n            </NavDropdown.Item>\n          ))}\n        </NavDropdown>\n        <Nav.Link onClick={handleToggle}>Show Numbers</Nav.Link>\n      </Navbar.Collapse>\n    </Navbar>\n  );\n}\n","import React from 'react';\nimport StartImg from '../imgs/start.png';\nimport EndImg from '../imgs/end.png';\n\nimport './Legend.scss';\nexport default function Legend(props) {\n  return (\n    <div id='pathfinding-legend'>\n      <ul className='legend-container'>\n        <li>\n          <img src={StartImg} alt='start node'></img>\n          <span className='legend-text'>Start Node</span>\n        </li>\n        <li>\n          <img src={EndImg} alt='target node'></img>\n          <span className='legend-text'>Target Node</span>\n        </li>\n        <li>\n          <div className='legend-unvisited'></div>\n          <span className='legend-text'>Unvisited Node</span>\n        </li>\n        <li>\n          <div className='legend-visited'></div>\n          <span className='legend-text'>Visited Node</span>\n        </li>\n        <li>\n          <div className='legend-shortest-path'></div>\n          <span className='legend-text'>Shortest Path</span>\n        </li>\n        <li>\n          <div className='legend-wall'></div>\n          <span className='legend-text'>Wall</span>\n        </li>\n      </ul>\n      <div className='legend-msg'>Visualize an algorithm!</div>\n    </div>\n  );\n}\n","export function dijkstra(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n\n  // use !! to force boolean conversion\n  while (!!unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift(); // Get the first Node\n\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n\n    // If the closest node is a distance of ifinity,\n    // we must be trapped and should therefore stop.\n\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n}\n\nconst sortNodesByDistance = function(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n};\n\nconst updateUnvisitedNeighbors = function(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n};\n\nconst getUnvisitedNeighbors = function(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n};\n\n// split into utility function\nconst getAllNodes = function(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n};\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above\nexport function getNodesInShortestPathOrder(finishNode) {\n  const getNodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    getNodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n\n  return getNodesInShortestPathOrder;\n}\n","const getUnvisitedNeighbors = function(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  // console.log(neighbors.filter(neighbor => !neighbor.isVisited));\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n};\n\nexport function getBiDirectionalShortestPath(middleNode) {\n  const fromStart = [];\n  const fromFinish = [];\n\n  let toStart = middleNode;\n  let toEnd = middleNode.biPreviousNode;\n  while (toStart !== null) {\n    fromStart.push(toStart);\n    toStart = toStart.previousNode;\n  }\n  while (toEnd !== null) {\n    fromFinish.push(toEnd);\n    toEnd = toEnd.biPreviousNode;\n  }\n  const shortestPath = fromStart.reverse().concat(fromFinish);\n  return shortestPath;\n}\n\nexport function bi_bfs(grid, startNode, finishNode) {\n  const [middleNode, visitedNodesInOrder] = _bi_bfs(grid, startNode, finishNode);\n  return [visitedNodesInOrder, middleNode];\n}\n\nfunction _bi_bfs(grid, startNode, finishNode) {\n  const unvisitedNodesStart = [startNode];\n  const unvisitedNodesFinish = [finishNode];\n  const visitedNodesInOrder = [];\n  const exploredNodesStart = {};\n  const exploredNodesFinish = {};\n  startNode.distance = 0;\n  finishNode.biDistance = 0;\n\n  while (unvisitedNodesStart.length && unvisitedNodesFinish.length) {\n    // for (let i = 0; i < 5; i++) {\n    let startingCurrentNode = unvisitedNodesStart.shift();\n    // FINISH NODE\n    let finishCurrentNode = unvisitedNodesFinish.shift();\n    // If we encounter a wall, we skip it.\n\n    if (startingCurrentNode.isWall) continue;\n    if (finishCurrentNode.isWall) continue;\n\n    // If the current node is a distance of ifinity,\n    // we must be trapped and should therefore stop.\n\n    if (startingCurrentNode.distance === Infinity || finishCurrentNode.biDistance === Infinity) return visitedNodesInOrder;\n\n    // visited node\n    if (!startingCurrentNode.isStart && !finishCurrentNode.isFinish) {\n      if (exploredNodesFinish[startingCurrentNode.id]) {\n        // console.log('EXPLOREDNODE', exploredNodes);\n        console.log('VISITED NODES', visitedNodesInOrder);\n        console.log('startingNode', startingCurrentNode);\n        return [startingCurrentNode, visitedNodesInOrder];\n      } else if (exploredNodesStart[finishCurrentNode.id]) {\n        console.log('VISITED NODES', visitedNodesInOrder);\n        console.log('EndingNode', finishCurrentNode);\n        return [finishCurrentNode, visitedNodesInOrder];\n      } else if (startingCurrentNode.id === finishCurrentNode.id) {\n        console.log('THEY MATCH');\n        return visitedNodesInOrder;\n      }\n    }\n\n    startingCurrentNode.isVisited = true;\n    finishCurrentNode.isVisited = true;\n\n    exploredNodesStart[startingCurrentNode.id] = true;\n    exploredNodesFinish[finishCurrentNode.id] = true;\n    visitedNodesInOrder.push(startingCurrentNode);\n    visitedNodesInOrder.push(finishCurrentNode);\n\n    const currentNeighborsStart = getUnvisitedNeighbors(startingCurrentNode, grid);\n    currentNeighborsStart.forEach(neighbor => {\n      if (!exploredNodesStart[neighbor.id]) {\n        neighbor.distance = startingCurrentNode.distance + 1;\n        neighbor.previousNode = startingCurrentNode;\n        unvisitedNodesStart.push(neighbor);\n      }\n    });\n\n    const currentNeighborsFinish = getUnvisitedNeighbors(finishCurrentNode, grid);\n    currentNeighborsFinish.forEach(neighbor => {\n      if (!exploredNodesFinish[neighbor.id]) {\n        neighbor.biDistance = finishCurrentNode.biDistance + 1;\n        neighbor.biPreviousNode = finishCurrentNode;\n        unvisitedNodesFinish.push(neighbor);\n      }\n    });\n  }\n  return -1;\n}\n","const sortNodesByDistance = function(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n};\n\nconst updateUnvisitedNeighbors = function(node, grid, startNode, finishNode) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    updateNode(node, neighbor, startNode, finishNode);\n  }\n};\n\nconst updateNode = function(node, neighbor, startNode, finishNode) {\n  const distance = distanceFromNeighbor(node, neighbor);\n  const distanceToCompare = neighbor.weight + distance + manhattanDistance(neighbor, finishNode);\n\n  if (distanceToCompare < neighbor.distance) {\n    neighbor.distance = distanceToCompare;\n    neighbor.previousNode = node;\n  }\n};\n\nfunction distanceFromNeighbor(node, neighbor) {\n  if (node.row === neighbor.row - 1 && node.col === neighbor.col) {\n    // console.log('LEFT');\n    return 1;\n  }\n  if (node.row === neighbor.row + 1 && node.col === neighbor.col) {\n    // console.log('RIGHT');\n    return 1;\n  }\n  if (node.col === neighbor.col + 1 && node.row === neighbor.row) {\n    // console.log('UP');\n    return 1;\n  }\n  if (node.col === neighbor.col - 1 && node.row === neighbor.row) {\n    // console.log('DOWN');\n    return 1;\n  }\n}\n\nfunction manhattanDistance(node, targetNode) {\n  let yChange = Math.abs(node.row - targetNode.row);\n  let xChange = Math.abs(node.col - targetNode.col);\n  return xChange + yChange;\n}\n\nconst getUnvisitedNeighbors = function(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n};\n\n// split into utility function\nconst getAllNodes = function(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n};\n\n// Backtracks from the finishNode to find the shortest path.\nexport function getNodesInShortestPathOrder(finishNode) {\n  const getNodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    getNodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n\n  return getNodesInShortestPathOrder;\n}\n\nexport function bestfs(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n\n  // use !! to force boolean conversion\n  while (!!unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift(); // Get the first Node\n\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n\n    // If the closest node is a distance of ifinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n\n    visitedNodesInOrder.push(closestNode);\n\n    closestNode.isVisited = true;\n\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid, startNode, finishNode);\n  }\n}\n","const sortNodesByDistance = function(unvisitedNodes) {\n  // sort by total distance first, if they are the same, sortby heuristicdistance\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.totalDistance - nodeB.totalDistance || nodeA.heuristicDistance - nodeB.heuristicDistance);\n};\n\nconst updateNode = function(node, neighbor, startNode, finishNode) {\n  const distance = distanceFromNeighbor(node, neighbor);\n  // set heuristic distance if there isnt one\n  if (!neighbor.heuristicDistance) neighbor.heuristicDistance = manhattanDistance(neighbor, finishNode);\n  const distanceToCompare = neighbor.weight + distance + node.distance;\n\n  if (distanceToCompare < neighbor.distance) {\n    neighbor.distance = distanceToCompare;\n    neighbor.totalDistance = neighbor.distance + neighbor.heuristicDistance;\n    neighbor.previousNode = node;\n  }\n};\n\nconst updateUnvisitedNeighbors = function(node, grid, startNode, finishNode) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    updateNode(node, neighbor, startNode, finishNode);\n  }\n};\n\nfunction distanceFromNeighbor(node, neighbor) {\n  if (node.row === neighbor.row - 1 && node.col === neighbor.col) {\n    // console.log('LEFT');\n    return 1;\n  }\n  if (node.row === neighbor.row + 1 && node.col === neighbor.col) {\n    // console.log('RIGHT');\n    return 1;\n  }\n  if (node.col === neighbor.col + 1 && node.row === neighbor.row) {\n    // console.log('UP');\n    return 1;\n  }\n  if (node.col === neighbor.col - 1 && node.row === neighbor.row) {\n    // console.log('DOWN');\n    return 1;\n  }\n}\n\nfunction manhattanDistance(node, targetNode) {\n  let yChange = Math.abs(node.row - targetNode.row);\n  let xChange = Math.abs(node.col - targetNode.col);\n  return xChange + yChange;\n}\n\nconst getUnvisitedNeighbors = function(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n};\n\n// split into utility function\nconst getAllNodes = function(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n};\n\n// Backtracks from the finishNode to find the shortest path.\nexport function getNodesInShortestPathOrder(finishNode) {\n  const getNodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    getNodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n\n  return getNodesInShortestPathOrder;\n}\n\nexport function astar(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n\n  startNode.distance = 0;\n  startNode.totalDistance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n\n  // use !! to force boolean conversion\n  while (!!unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    // console.log(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift(); // Get the first Node\n\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n\n    // If the closest node is a distance of ifinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n\n    visitedNodesInOrder.push(closestNode);\n\n    closestNode.isVisited = true;\n\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid, startNode, finishNode);\n  }\n}\n","function randomNumber(array) {\n  return Math.floor(Math.random() * array.length);\n}\n\nfunction randomColNRow(rowStart, rowEnd, colStart, colEnd, orientation) {\n  const possibleCols = [];\n  const possibleRows = [];\n  if (orientation === 'horizontal') {\n    // walls on even cells only\n    for (let number = rowStart; number <= rowEnd; number += 2) {\n      possibleRows.push(number);\n    }\n    // openings in odd cells only\n    for (let number = colStart - 1; number <= colEnd + 1; number += 2) {\n      possibleCols.push(number);\n    }\n  } else {\n    for (let number = colStart; number <= colEnd; number += 2) {\n      possibleCols.push(number);\n    }\n    for (let number = rowStart - 1; number <= rowEnd + 1; number += 2) {\n      possibleRows.push(number);\n    }\n  }\n  const randomColIndex = randomNumber(possibleCols);\n  const randomRowIndex = randomNumber(possibleRows);\n  const colRandom = possibleCols[randomColIndex];\n  const rowRandom = possibleRows[randomRowIndex];\n  return [colRandom, rowRandom];\n}\n\nconst getAllNodes = function(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n};\n\nfunction addOuterWalls(grid, array) {\n  const width = grid[0].length - 1;\n  const height = grid.length - 1;\n  for (let row = 0; row < grid.length; row++) {\n    if (row === 0 || row === height) {\n      for (let col = 0; col <= width; col++) {\n        const node = grid[row][col];\n        node.isWall = true;\n        array.push(node);\n      }\n    } else {\n      grid[row][0].isWall = true;\n      array.push(grid[row][0]);\n      grid[row][width].isWall = true;\n      array.push(grid[row][width]);\n    }\n  }\n  return array;\n}\n\nfunction addVerticalWall(grid, colStart, colEnd, colRandom, currentRow, array) {\n  getAllNodes(grid).forEach(node => {\n    if (node.row === currentRow && node.col !== colRandom && node.col >= colStart - 1 && node.col <= colEnd + 1) {\n      if (!node.isStart && !node.isFinish) {\n        node.isWall = true;\n        array.push(node);\n      }\n    }\n  });\n}\n\nfunction addHorizontalWall(grid, rowStart, rowEnd, rowRandom, currentCol, array) {\n  getAllNodes(grid).forEach(node => {\n    if (node.col === currentCol && node.row !== rowRandom && node.row >= rowStart - 1 && node.row <= rowEnd + 1) {\n      if (!node.isStart && !node.isFinish) {\n        node.isWall = true;\n        array.push(node);\n      }\n    }\n  });\n}\n\nfunction addInnerWalls(grid, rowStart, rowEnd, colStart, colEnd, orientation, array) {\n  if (orientation === 'horizontal') {\n    if (rowEnd < rowStart) {\n      return;\n    }\n\n    const [colRandom, currentRow] = randomColNRow(rowStart, rowEnd, colStart, colEnd, orientation);\n\n    addVerticalWall(grid, colStart, colEnd, colRandom, currentRow, array);\n\n    // check if remaining row from point or column is larger if # of rows from point is larger add another horizontal wall, else vertical wall\n    if (currentRow - 2 - rowStart > colEnd - colStart) {\n      addInnerWalls(grid, rowStart, currentRow - 2, colStart, colEnd, 'horizontal', array);\n    } else {\n      addInnerWalls(grid, rowStart, currentRow - 2, colStart, colEnd, 'vertical', array);\n    }\n    // check if remaining rows or column is larger if # of rows is larger add another horizontal wall, else vertical wall\n    if (rowEnd - (currentRow + 2) > colEnd - colStart) {\n      addInnerWalls(grid, currentRow + 2, rowEnd, colStart, colEnd, 'horizontal', array);\n    } else {\n      addInnerWalls(grid, currentRow + 2, rowEnd, colStart, colEnd, 'vertical', array);\n    }\n  } else if (orientation === 'vertical') {\n    if (colEnd < colStart) {\n      return;\n    }\n\n    let [currentCol, rowRandom] = randomColNRow(rowStart, rowEnd, colStart, colEnd, orientation);\n\n    addHorizontalWall(grid, rowStart, rowEnd, rowRandom, currentCol, array);\n\n    // check if remaining if either row or column is larger\n    if (rowEnd - rowStart > currentCol - 2 - colStart) {\n      addInnerWalls(grid, rowStart, rowEnd, colStart, currentCol - 2, 'horizontal', array);\n    } else {\n      addInnerWalls(grid, rowStart, rowEnd, colStart, currentCol - 2, 'vertical', array);\n    }\n    if (rowEnd - rowStart > colEnd - (currentCol + 2)) {\n      addInnerWalls(grid, rowStart, rowEnd, currentCol + 2, colEnd, 'horizontal', array);\n    } else {\n      addInnerWalls(grid, rowStart, rowEnd, currentCol + 2, colEnd, 'vertical', array);\n    }\n  }\n}\n\nexport default function recursiveDivision(grid) {\n  const wallsToAnimate = [];\n  addOuterWalls(grid, wallsToAnimate);\n  const row = grid.length;\n  const col = grid[0].length;\n  addInnerWalls(grid, 2, row - 3, 2, col - 3, 'horizontal', wallsToAnimate);\n  return wallsToAnimate;\n}\n","function randomNumber(array) {\n  return Math.floor(Math.random() * array.length);\n}\n\nfunction randomColNRow(rowStart, rowEnd, colStart, colEnd, orientation) {\n  const possibleCols = [];\n  const possibleRows = [];\n  if (orientation === 'horizontal') {\n    // walls on even cells only\n    for (let number = rowStart; number <= rowEnd; number += 2) {\n      possibleRows.push(number);\n    }\n    // openings in odd cells only\n    for (let number = colStart - 1; number <= colEnd + 1; number += 2) {\n      possibleCols.push(number);\n    }\n  } else {\n    for (let number = colStart; number <= colEnd; number += 2) {\n      possibleCols.push(number);\n    }\n    for (let number = rowStart - 1; number <= rowEnd + 1; number += 2) {\n      possibleRows.push(number);\n    }\n  }\n  const randomColIndex = randomNumber(possibleCols);\n  const randomRowIndex = randomNumber(possibleRows);\n  const colRandom = possibleCols[randomColIndex];\n  const rowRandom = possibleRows[randomRowIndex];\n  return [colRandom, rowRandom];\n}\n\nconst getAllNodes = function(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n};\n\nfunction addOuterWalls(grid, array) {\n  const width = grid[0].length - 1;\n  const height = grid.length - 1;\n  for (let row = 0; row < grid.length; row++) {\n    if (row === 0 || row === height) {\n      for (let col = 0; col <= width; col++) {\n        const node = grid[row][col];\n        node.isWall = true;\n        array.push(node);\n      }\n    } else {\n      grid[row][0].isWall = true;\n      array.push(grid[row][0]);\n      grid[row][width].isWall = true;\n      array.push(grid[row][width]);\n    }\n  }\n  return array;\n}\n\nfunction addVerticalWall(grid, colStart, colEnd, colRandom, currentRow, array) {\n  getAllNodes(grid).forEach(node => {\n    if (node.row === currentRow && node.col !== colRandom && node.col >= colStart - 1 && node.col <= colEnd + 1) {\n      if (!node.isStart && !node.isFinish) {\n        node.isWall = true;\n        array.push(node);\n      }\n    }\n  });\n}\n\nfunction addHorizontalWall(grid, rowStart, rowEnd, rowRandom, currentCol, array) {\n  getAllNodes(grid).forEach(node => {\n    if (node.col === currentCol && node.row !== rowRandom && node.row >= rowStart - 1 && node.row <= rowEnd + 1) {\n      if (!node.isStart && !node.isFinish) {\n        node.isWall = true;\n        array.push(node);\n      }\n    }\n  });\n}\n\nfunction addInnerWalls(grid, rowStart, rowEnd, colStart, colEnd, orientation, array) {\n  if (orientation === 'horizontal') {\n    if (rowEnd < rowStart) {\n      return;\n    }\n\n    const [colRandom, currentRow] = randomColNRow(rowStart, rowEnd, colStart, colEnd, orientation);\n\n    addVerticalWall(grid, colStart, colEnd, colRandom, currentRow, array);\n\n    // check if remaining row from point or column is larger if # of rows from point is larger add another horizontal wall, else vertical wall\n    if (currentRow - 2 - rowStart > colEnd - colStart) {\n      addInnerWalls(grid, rowStart, currentRow - 2, colStart, colEnd, 'horizontal', array);\n    } else {\n      addInnerWalls(grid, rowStart, currentRow - 2, colStart, colEnd, 'vertical', array);\n    }\n    // check if remaining rows or column is larger if # of rows is larger add another horizontal wall, else vertical wall\n    if (rowEnd - (currentRow + 2) > colEnd - colStart) {\n      addInnerWalls(grid, currentRow + 2, rowEnd, colStart, colEnd, 'vertical', array);\n    } else {\n      addInnerWalls(grid, currentRow + 2, rowEnd, colStart, colEnd, 'vertical', array);\n    }\n  } else if (orientation === 'vertical') {\n    if (colEnd < colStart) {\n      return;\n    }\n\n    let [currentCol, rowRandom] = randomColNRow(rowStart, rowEnd, colStart, colEnd, orientation);\n\n    addHorizontalWall(grid, rowStart, rowEnd, rowRandom, currentCol, array);\n\n    // check if remaining if either row or column is larger\n    if (rowEnd - rowStart > currentCol - 2 - colStart) {\n      addInnerWalls(grid, rowStart, rowEnd, colStart, currentCol - 2, 'vertical', array);\n    } else {\n      addInnerWalls(grid, rowStart, rowEnd, colStart, currentCol - 2, 'vertical', array);\n    }\n    if (rowEnd - rowStart > colEnd - (currentCol + 2)) {\n      addInnerWalls(grid, rowStart, rowEnd, currentCol + 2, colEnd, 'horizontal', array);\n    } else {\n      addInnerWalls(grid, rowStart, rowEnd, currentCol + 2, colEnd, 'vertical', array);\n    }\n  }\n}\n\nexport default function recursiveVertical(grid) {\n  const wallsToAnimate = [];\n  addOuterWalls(grid, wallsToAnimate);\n  const row = grid.length;\n  const col = grid[0].length;\n  addInnerWalls(grid, 2, row - 3, 2, col - 3, 'horizontal', wallsToAnimate);\n  return wallsToAnimate;\n}\n","function randomNumber(array) {\n  return Math.floor(Math.random() * array.length);\n}\n\nfunction randomColNRow(rowStart, rowEnd, colStart, colEnd, orientation) {\n  const possibleCols = [];\n  const possibleRows = [];\n  if (orientation === 'horizontal') {\n    // walls on even cells only\n    for (let number = rowStart; number <= rowEnd; number += 2) {\n      possibleRows.push(number);\n    }\n    // openings in odd cells only\n    for (let number = colStart - 1; number <= colEnd + 1; number += 2) {\n      possibleCols.push(number);\n    }\n  } else {\n    for (let number = colStart; number <= colEnd; number += 2) {\n      possibleCols.push(number);\n    }\n    for (let number = rowStart - 1; number <= rowEnd + 1; number += 2) {\n      possibleRows.push(number);\n    }\n  }\n  const randomColIndex = randomNumber(possibleCols);\n  const randomRowIndex = randomNumber(possibleRows);\n  const colRandom = possibleCols[randomColIndex];\n  const rowRandom = possibleRows[randomRowIndex];\n  return [colRandom, rowRandom];\n}\n\nconst getAllNodes = function(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n};\n\nfunction addOuterWalls(grid, array) {\n  const width = grid[0].length - 1;\n  const height = grid.length - 1;\n  for (let row = 0; row < grid.length; row++) {\n    if (row === 0 || row === height) {\n      for (let col = 0; col <= width; col++) {\n        const node = grid[row][col];\n        node.isWall = true;\n        array.push(node);\n      }\n    } else {\n      grid[row][0].isWall = true;\n      array.push(grid[row][0]);\n      grid[row][width].isWall = true;\n      array.push(grid[row][width]);\n    }\n  }\n  return array;\n}\n\nfunction addVerticalWall(grid, colStart, colEnd, colRandom, currentRow, array) {\n  getAllNodes(grid).forEach(node => {\n    if (node.row === currentRow && node.col !== colRandom && node.col >= colStart - 1 && node.col <= colEnd + 1) {\n      if (!node.isStart && !node.isFinish) {\n        node.isWall = true;\n        array.push(node);\n      }\n    }\n  });\n}\n\nfunction addHorizontalWall(grid, rowStart, rowEnd, rowRandom, currentCol, array) {\n  getAllNodes(grid).forEach(node => {\n    if (node.col === currentCol && node.row !== rowRandom && node.row >= rowStart - 1 && node.row <= rowEnd + 1) {\n      if (!node.isStart && !node.isFinish) {\n        node.isWall = true;\n        array.push(node);\n      }\n    }\n  });\n}\n\nfunction addInnerWalls(grid, rowStart, rowEnd, colStart, colEnd, orientation, array) {\n  if (orientation === 'horizontal') {\n    if (rowEnd < rowStart) {\n      return;\n    }\n\n    const [colRandom, currentRow] = randomColNRow(rowStart, rowEnd, colStart, colEnd, orientation);\n\n    addVerticalWall(grid, colStart, colEnd, colRandom, currentRow, array);\n\n    // check if remaining row from point or column is larger if # of rows from point is larger add another horizontal wall, else vertical wall\n    if (currentRow - 2 - rowStart > colEnd - colStart) {\n      addInnerWalls(grid, rowStart, currentRow - 2, colStart, colEnd, 'horizontal', array);\n    } else {\n      addInnerWalls(grid, rowStart, currentRow - 2, colStart, colEnd, 'horizontal', array);\n    }\n    // check if remaining rows or column is larger if # of rows is larger add another horizontal wall, else vertical wall\n    if (rowEnd - (currentRow + 2) > colEnd - colStart) {\n      addInnerWalls(grid, currentRow + 2, rowEnd, colStart, colEnd, 'horizontal', array);\n    } else {\n      addInnerWalls(grid, currentRow + 2, rowEnd, colStart, colEnd, 'vertical', array);\n    }\n  } else if (orientation === 'vertical') {\n    if (colEnd < colStart) {\n      return;\n    }\n\n    let [currentCol, rowRandom] = randomColNRow(rowStart, rowEnd, colStart, colEnd, orientation);\n\n    addHorizontalWall(grid, rowStart, rowEnd, rowRandom, currentCol, array);\n\n    // check if remaining if either row or column is larger\n    if (rowEnd - rowStart > currentCol - 2 - colStart) {\n      addInnerWalls(grid, rowStart, rowEnd, colStart, currentCol - 2, 'horizontal', array);\n    } else {\n      addInnerWalls(grid, rowStart, rowEnd, colStart, currentCol - 2, 'horizontal', array);\n    }\n    if (rowEnd - rowStart > colEnd - (currentCol + 2)) {\n      addInnerWalls(grid, rowStart, rowEnd, currentCol + 2, colEnd, 'horizontal', array);\n    } else {\n      addInnerWalls(grid, rowStart, rowEnd, currentCol + 2, colEnd, 'vertical', array);\n    }\n  }\n}\n\nexport default function recursiveVertical(grid) {\n  const wallsToAnimate = [];\n  addOuterWalls(grid, wallsToAnimate);\n  const row = grid.length;\n  const col = grid[0].length;\n  addInnerWalls(grid, 2, row - 3, 2, col - 3, 'horizontal', wallsToAnimate);\n  return wallsToAnimate;\n}\n","import React, { useState, useEffect, useContext } from 'react';\nimport Node from './Node';\nimport NavBar from './NavBar';\nimport Legend from './Legend';\nimport { dijkstra, getNodesInShortestPathOrder, dfs, bfs, bestfs, astar, getBiDirectionalShortestPath, bi_bfs } from '../algorithms/index';\nimport { pathfindingContext } from '../context/pathfindingContext';\nimport { basicRandom, recursiveDivision, recursiveVertical, recursiveHorizontal } from '../maze-algorithms/index';\n\nimport './PathfindingVisualizer.scss';\n\nconst nodesToUpdate = [];\n\nconst createNode = function(col, row, startNode, finishNode) {\n  return {\n    id: `${row}-${col}`,\n    col,\n    row,\n    isStart: row === startNode.row && col === startNode.col,\n    isFinish: row === finishNode.row && col === finishNode.col,\n    distance: Infinity,\n    biDistance: Infinity,\n    totalDistance: Infinity,\n    heuristicDistance: null,\n    isVisited: false,\n    isWall: false,\n    previousNode: null,\n    biPreviousNode: null,\n    weight: 0,\n  };\n};\n\nfunction resetNode(node) {\n  return {\n    ...node,\n    distance: Infinity,\n    totalDistance: Infinity,\n    heuristicDistance: null,\n    isVisited: false,\n    isWall: false,\n    previousNode: null,\n    weight: 0,\n  };\n}\n\nconst getInitialGrid = function(startNode, finishNode) {\n  const grid = [];\n  // best size is row 31 col 78\n  for (let row = 0; row < 31; row++) {\n    const currentRow = [];\n    for (let col = 0; col < 78; col++) {\n      currentRow.push(createNode(col, row, startNode, finishNode));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\n// const getNewGridWithWallToggled = function(grid, row, col) {\n//   /* preformance issues - too many rerenders*/\n//   // const newGrid = grid.slice();\n//   // const node = newGrid[row][col];\n//   // const newNode = {\n//   //   ...node,\n//   //   isWall: !node.isWall,\n//   // };\n//   // // update the newNode\n//   // newGrid[row][col] = newNode;\n//   // return newGrid;\n// };\n\nconst dragEnterNode = function(grid, row, col, type, array = null) {\n  const node = grid[row][col];\n  switch (type) {\n    case 'START':\n      document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-start';\n      break;\n    case 'END':\n      document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-finish';\n      break;\n    case 'WALL':\n      /* Hacky Solution for now */\n      // const newNode = {\n      //   ...node,\n      //   isWall: !node.isWall,\n      // };\n      // grid[row][col] = newNode;\n\n      if (node.isStart || node.isFinish) return;\n      /* changed to batch update wall Nodes */\n      const newNode = { ...node, isWall: !node.isWall };\n      array.push(newNode);\n\n      document.getElementById(`node-${node.row}-${node.col}`).className = node.isWall ? 'node' : 'node-wall';\n      break;\n    default:\n      console.log('not a predefined case');\n      return;\n  }\n};\n\nconst dragLeaveNode = function(grid, row, col) {\n  const node = grid[row][col];\n  if (node.isWall) {\n    document.getElementById(`node-${node.row}-${node.col}`).className = 'node-wall';\n  } else {\n    document.getElementById(`node-${node.row}-${node.col}`).className = 'node node';\n  }\n};\n\nconst setNode = function(grid, row, col, type) {\n  const node = grid[row][col];\n  let newNode = {};\n  switch (type) {\n    case 'START':\n      newNode = {\n        ...node,\n        isStart: !node.isStart,\n      };\n      grid[row][col] = newNode;\n      document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-start';\n      break;\n    case 'END':\n      newNode = {\n        ...node,\n        isFinish: !node.isFinish,\n      };\n      grid[row][col] = newNode;\n      document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-finish';\n      break;\n    default:\n      console.log('not a predefined case');\n      return;\n  }\n};\n\nconst updatedGridWithWalls = function(grid, nodesToUpdate) {\n  // Manually Batch Update Wall Nodes\n  const newGrid = grid.slice();\n  nodesToUpdate.forEach(node => {\n    newGrid[node.row][node.col] = node;\n  });\n  return newGrid;\n};\n\nexport default function PathfindingVisualizer(props) {\n  // console.log('RENDERING GRID');\n  const [grid, setGrid] = useState([]);\n  const [mouseIsPressed, setMouseIsPressed] = useState(false);\n  const { state, dispatch } = useContext(pathfindingContext);\n\n  const START_NODE = state.startNode;\n  const END_NODE = state.endNode;\n\n  useEffect(() => {\n    const grid = getInitialGrid(START_NODE, END_NODE);\n    setGrid(grid);\n  }, []);\n\n  return (\n    <div id='pathfinding-visualizer'>\n      <NavBar visualizeClick={visualizePath} mazeClick={visualizeMaze} resetClick={resetGrid} clearClick={clearPath} />\n      <Legend />\n      <div className='grid'>{renderGrid(grid)}</div>\n    </div>\n  );\n\n  function renderGrid(grid) {\n    return grid.map((row, rowIdx) => {\n      return (\n        <div key={rowIdx} className='grid-row'>\n          {row.map((node, nodeIdx) => {\n            const { row, col, isFinish, isStart, isWall, distance, totalDistance } = node;\n            return (\n              <Node\n                key={nodeIdx}\n                col={col}\n                isFinish={isFinish}\n                isStart={isStart}\n                isWall={isWall}\n                onMouseDown={(row, col) => handleMouseDown(row, col)}\n                onMouseEnter={(row, col) => handleMouseEnter(row, col)}\n                onMouseLeave={(row, col) => handleMouseLeave(row, col)}\n                onMouseUp={(row, col) => handleMouseUp(row, col)}\n                row={row}\n                showNumbers={state.showNumbers}\n                distance={distance}\n                totalDistance={totalDistance}></Node>\n            );\n          })}\n        </div>\n      );\n    });\n  }\n\n  function handleMouseDown(row, col) {\n    if (grid[row][col].isStart) {\n      // setMovingStart(true);\n      setMouseIsPressed('START');\n      dragEnterNode(grid, row, col, 'START');\n    } else if (grid[row][col].isFinish) {\n      // setMovingEnd(true);\n      setMouseIsPressed('END');\n      dragEnterNode(grid, row, col, 'END');\n    } else {\n      // setMouseIsPressed(true);\n      setMouseIsPressed('WALL');\n      dragEnterNode(grid, row, col, 'WALL', nodesToUpdate);\n    }\n  }\n\n  function handleMouseEnter(row, col) {\n    if (mouseIsPressed === 'START') dragEnterNode(grid, row, col, 'START');\n    if (mouseIsPressed === 'END') dragEnterNode(grid, row, col, 'END');\n    if (mouseIsPressed === 'WALL') dragEnterNode(grid, row, col, 'WALL', nodesToUpdate);\n  }\n\n  function handleMouseLeave(row, col) {\n    if (mouseIsPressed === 'START' || mouseIsPressed === 'END') {\n      dragLeaveNode(grid, row, col);\n    }\n  }\n\n  function handleMouseUp(row, col) {\n    if (mouseIsPressed === 'START') {\n      setNode(grid, row, col, 'START');\n      dispatch({ type: 'SET_START_NODE', payload: { row, col } });\n    }\n\n    if (mouseIsPressed === 'END') {\n      setNode(grid, row, col, 'END');\n      dispatch({ type: 'SET_END_NODE', payload: { row, col } });\n    }\n\n    if (mouseIsPressed === 'WALL') {\n      // ensures render of grid\n      const newGrid = updatedGridWithWalls(grid, nodesToUpdate);\n      // clear queue\n      nodesToUpdate.length = 0;\n      setGrid(newGrid);\n    }\n\n    setMouseIsPressed(false);\n    // setMovingStart(false);\n    // setMovingEnd(false);\n  }\n\n  function animatePath(visitedNodesInOrder, nodesInShortestPathOrder) {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          animateShortestPath(nodesInShortestPathOrder);\n        }, state.speed.visited * i);\n        // optimal 10\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        // hacky solution to minimize rerenders\n        // TODO: look into useRef to achieve similar result\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited';\n      }, state.speed.visited * i);\n      // optimal 10\n    }\n  }\n\n  function animateShortestPath(nodesInShortestPathOrder) {\n    for (let i = 0; i <= nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-shortest-path';\n      }, state.speed.shortestPath * i);\n      // optimal 50\n    }\n  }\n\n  function setAlgorithm(algorithm, grid, startNode, endNode) {\n    switch (algorithm) {\n      case 'DJISKTRA':\n        return dijkstra(grid, startNode, endNode);\n      case 'BREADTH_FIRST_SEARCH':\n        return bfs(grid, startNode, endNode);\n      case 'DEPTH_FIRST_SEARCH':\n        return dfs(grid, startNode, endNode);\n      case 'BEST_FIRST_SEARCH':\n        return bestfs(grid, startNode, endNode);\n      case 'A_STAR':\n        return astar(grid, startNode, endNode);\n      case 'BI_DIRECTIONAL_BFS':\n        return bi_bfs(grid, startNode, endNode);\n      default:\n        console.log('UNIMPLEMENTED ALGORITHM \\n DEFAULT SET TO DJISKTRA');\n        return dijkstra(grid, startNode, endNode);\n    }\n  }\n\n  function visualizePath() {\n    const startNode = grid[state.startNode.row][state.startNode.col];\n    const endNode = grid[state.endNode.row][state.endNode.col];\n    let visitedNodesInOrder;\n    let middleNode;\n    let nodesInShortestPathOrder;\n    if (state.currentAlgorithm === 'BI_DIRECTIONAL_BFS') {\n      [visitedNodesInOrder, middleNode] = setAlgorithm(state.currentAlgorithm, grid, startNode, endNode);\n      nodesInShortestPathOrder = getBiDirectionalShortestPath(middleNode);\n    } else {\n      visitedNodesInOrder = setAlgorithm(state.currentAlgorithm, grid, startNode, endNode);\n      nodesInShortestPathOrder = getNodesInShortestPathOrder(endNode);\n    }\n    animatePath(visitedNodesInOrder, nodesInShortestPathOrder);\n  }\n\n  function visualizeMaze(maze) {\n    let wallNodesInOrder;\n\n    switch (maze) {\n      case 'RECURSIVE_DIVISION':\n        wallNodesInOrder = recursiveDivision(grid);\n        break;\n      case 'BASIC_RANDOM':\n        wallNodesInOrder = basicRandom(grid);\n        break;\n      case 'RECURSIVE_VERTICAL':\n        wallNodesInOrder = recursiveVertical(grid);\n        break;\n      case 'RECURSIVE_HORIZONTAL':\n        wallNodesInOrder = recursiveHorizontal(grid);\n        break;\n      default:\n        wallNodesInOrder = recursiveDivision(grid);\n        break;\n    }\n    animateMaze(wallNodesInOrder);\n  }\n\n  function animateMaze(visitedNodesInOrder) {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        // hacky solution to minimize rerenders\n        // TODO: look into useRef to achieve similar result\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node-wall';\n      }, 10 * i);\n    }\n  }\n\n  function resetGrid() {\n    const newGrid = grid.slice();\n    for (let row = 0; row < newGrid.length; row++) {\n      for (let col = 0; col < newGrid[row].length; col++) {\n        if (grid[row][col].isStart) {\n          const node = grid[row][col];\n          const newNode = resetNode(node);\n          grid[row][col] = newNode;\n          document.getElementById(`node-${row}-${col}`).className = 'node node-start';\n          continue;\n        }\n        if (grid[row][col].isFinish) {\n          const node = grid[row][col];\n          const newNode = resetNode(node);\n          grid[row][col] = newNode;\n          document.getElementById(`node-${row}-${col}`).className = 'node node-finish';\n          continue;\n        }\n        const node = grid[row][col];\n        const newNode = resetNode(node);\n        grid[row][col] = newNode;\n        document.getElementById(`node-${row}-${col}`).className = 'node';\n      }\n    }\n    setGrid(newGrid);\n  }\n\n  function clearPath() {\n    const newGrid = grid.slice();\n    for (let row = 0; row < newGrid.length; row++) {\n      for (let col = 0; col < newGrid[row].length; col++) {\n        const node = grid[row][col];\n        let newNode = resetNode(node);\n        if (node.isWall) {\n          newNode = { ...newNode, isWall: true };\n        }\n        grid[row][col] = newNode;\n        if (newNode.isStart) {\n          document.getElementById(`node-${row}-${col}`).className = 'node node-start';\n          continue;\n        } else if (newNode.isFinish) {\n          document.getElementById(`node-${row}-${col}`).className = 'node node-finish';\n          continue;\n        } else if (newNode.isWall) {\n          document.getElementById(`node-${row}-${col}`).className = 'node-wall';\n        } else {\n          document.getElementById(`node-${row}-${col}`).className = 'node';\n        }\n      }\n    }\n    setGrid(newGrid);\n  }\n}\n","export default function basicRandom(grid) {\n  const wallsToAnimate = [];\n  let currentY = grid[0].length - 10;\n  for (let i = 0; i < 20; i++) {\n    for (let counter = 0; counter < 15; counter++) {\n      currentY = Math.floor(Math.random() * grid[0].length);\n      const currentXOne = Math.floor(grid.length / 2) - counter;\n      const currentXTwo = Math.floor(grid.length / 2) + counter;\n      const currentNodeOne = grid[currentXOne][currentY];\n      const currentNodeTwo = grid[currentXTwo][currentY];\n      if (currentNodeOne.isStart || currentNodeOne.isFinish) continue;\n      if (currentNodeTwo.isStart || currentNodeTwo.isFinish) continue;\n\n      wallsToAnimate.push(currentNodeOne);\n      wallsToAnimate.push(currentNodeTwo);\n      currentNodeOne.isWall = true;\n      currentNodeTwo.isWall = true;\n    }\n  }\n  return wallsToAnimate;\n}\n","const getUnvisitedNeighbors = function(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n};\n\nexport function bfs(grid, startNode, finishNode) {\n  const unvisitedNodes = [startNode];\n  let exploredNodes = { [startNode.id]: true };\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n\n  while (unvisitedNodes.length) {\n    let currentNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (currentNode.isWall) continue;\n\n    // If the closest node is a distance of ifinity,\n    // we must be trapped and should therefore stop.\n\n    if (currentNode.distance === Infinity) return visitedNodesInOrder;\n\n    if (currentNode === finishNode) return visitedNodesInOrder;\n    currentNode.isVisited = true;\n    visitedNodesInOrder.push(currentNode);\n    const currentNeighbors = getUnvisitedNeighbors(currentNode, grid);\n    currentNeighbors.forEach(neighbor => {\n      if (!exploredNodes[neighbor.id]) {\n        exploredNodes[neighbor.id] = true;\n        neighbor.distance = currentNode.distance + 1;\n        neighbor.previousNode = currentNode;\n        unvisitedNodes.push(neighbor);\n      }\n    });\n  }\n  return -1;\n}\n","const getUnvisitedNeighbors = function(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.unshift(grid[row - 1][col]);\n  if (col < grid[0].length - 1) neighbors.unshift(grid[row][col + 1]);\n  if (row < grid.length - 1) neighbors.unshift(grid[row + 1][col]);\n  if (col > 0) neighbors.unshift(grid[row][col - 1]);\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n};\n\nexport function dfs(grid, startNode, finishNode) {\n  const unvisitedNodes = [startNode];\n  let exploredNodes = { [startNode.id]: true };\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n\n  while (unvisitedNodes.length) {\n    let currentNode = unvisitedNodes.pop();\n    exploredNodes[currentNode.id] = true;\n    // If we encounter a wall, we skip it.\n    if (currentNode.isWall) continue;\n\n    // If the closest node is a distance of ifinity,\n    // we must be trapped and should therefore stop.\n\n    // if (currentNode.distance === Infinity) return visitedNodesInOrder;\n\n    if (currentNode === finishNode) return visitedNodesInOrder;\n    currentNode.isVisited = true;\n    visitedNodesInOrder.push(currentNode);\n    const currentNeighbors = getUnvisitedNeighbors(currentNode, grid);\n    currentNeighbors.forEach(neighbor => {\n      if (!exploredNodes[neighbor.id]) {\n        neighbor.distance = currentNode.distance + 1;\n        neighbor.previousNode = currentNode;\n        unvisitedNodes.push(neighbor);\n      }\n    });\n  }\n  return -1;\n}\n","import React from 'react';\nimport PathfindingVisualizer from './components/PathfindingVisualizer';\nimport './custom.scss';\nimport './App.scss';\n\nimport PathfindingContextProvider from './context/pathfindingContext';\n\nconst App = function() {\n  return (\n    <div className='App'>\n      <PathfindingContextProvider>\n        <PathfindingVisualizer></PathfindingVisualizer>\n      </PathfindingContextProvider>\n    </div>\n  );\n};\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}